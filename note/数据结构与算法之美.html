<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>《数据结构与算法之美》 | 十号</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="https://cdn.jsdelivr.net/gh/AsherSun/image-host/blog-img/xiuxian-logo.png">
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/assets/css/0.styles.a883148b.css" as="style"><link rel="preload" href="/assets/js/app.730fe383.js" as="script"><link rel="preload" href="/assets/js/3.9989142c.js" as="script"><link rel="preload" href="/assets/js/1.3a008db8.js" as="script"><link rel="preload" href="/assets/js/44.623633a1.js" as="script"><link rel="prefetch" href="/assets/js/10.3b912a2d.js"><link rel="prefetch" href="/assets/js/11.95014e5f.js"><link rel="prefetch" href="/assets/js/12.38f3c8e8.js"><link rel="prefetch" href="/assets/js/13.41755f38.js"><link rel="prefetch" href="/assets/js/14.e1655ac0.js"><link rel="prefetch" href="/assets/js/15.bce327d3.js"><link rel="prefetch" href="/assets/js/16.49b25e54.js"><link rel="prefetch" href="/assets/js/17.f1e266da.js"><link rel="prefetch" href="/assets/js/18.df83387c.js"><link rel="prefetch" href="/assets/js/19.30b3797f.js"><link rel="prefetch" href="/assets/js/20.2fdb598a.js"><link rel="prefetch" href="/assets/js/21.20fe2213.js"><link rel="prefetch" href="/assets/js/22.fde4fe00.js"><link rel="prefetch" href="/assets/js/23.29cb0f79.js"><link rel="prefetch" href="/assets/js/24.d53a8ebc.js"><link rel="prefetch" href="/assets/js/25.fc4aade1.js"><link rel="prefetch" href="/assets/js/26.a5747852.js"><link rel="prefetch" href="/assets/js/27.633e32cc.js"><link rel="prefetch" href="/assets/js/28.01f60ae7.js"><link rel="prefetch" href="/assets/js/29.b2c02be7.js"><link rel="prefetch" href="/assets/js/30.66607d96.js"><link rel="prefetch" href="/assets/js/31.fe42273d.js"><link rel="prefetch" href="/assets/js/32.6b9be322.js"><link rel="prefetch" href="/assets/js/33.4dbe597e.js"><link rel="prefetch" href="/assets/js/34.988e10fd.js"><link rel="prefetch" href="/assets/js/35.1fdb4c41.js"><link rel="prefetch" href="/assets/js/36.dc1941b7.js"><link rel="prefetch" href="/assets/js/37.bb0cb555.js"><link rel="prefetch" href="/assets/js/38.417a229f.js"><link rel="prefetch" href="/assets/js/39.d10940f4.js"><link rel="prefetch" href="/assets/js/4.500ff704.js"><link rel="prefetch" href="/assets/js/40.90cdab13.js"><link rel="prefetch" href="/assets/js/41.f5a89841.js"><link rel="prefetch" href="/assets/js/42.a5250d52.js"><link rel="prefetch" href="/assets/js/43.d2b53984.js"><link rel="prefetch" href="/assets/js/45.a27fb66c.js"><link rel="prefetch" href="/assets/js/46.31453659.js"><link rel="prefetch" href="/assets/js/47.eddae06a.js"><link rel="prefetch" href="/assets/js/48.72596aa6.js"><link rel="prefetch" href="/assets/js/49.9f4d8f5b.js"><link rel="prefetch" href="/assets/js/5.47968762.js"><link rel="prefetch" href="/assets/js/50.63a79e0d.js"><link rel="prefetch" href="/assets/js/51.478b1b37.js"><link rel="prefetch" href="/assets/js/52.f006a0fc.js"><link rel="prefetch" href="/assets/js/53.f0ad8ec6.js"><link rel="prefetch" href="/assets/js/54.9b290e0b.js"><link rel="prefetch" href="/assets/js/55.1e86cfcc.js"><link rel="prefetch" href="/assets/js/56.da03d2fe.js"><link rel="prefetch" href="/assets/js/57.2c0018f9.js"><link rel="prefetch" href="/assets/js/58.0672aa51.js"><link rel="prefetch" href="/assets/js/59.b2e0a946.js"><link rel="prefetch" href="/assets/js/6.8b224979.js"><link rel="prefetch" href="/assets/js/60.f1f1fd89.js"><link rel="prefetch" href="/assets/js/61.20d6fc0f.js"><link rel="prefetch" href="/assets/js/62.31dadbfb.js"><link rel="prefetch" href="/assets/js/63.d2b3651e.js"><link rel="prefetch" href="/assets/js/64.89143d31.js"><link rel="prefetch" href="/assets/js/65.d85f1f89.js"><link rel="prefetch" href="/assets/js/66.976129a6.js"><link rel="prefetch" href="/assets/js/67.dca6b101.js"><link rel="prefetch" href="/assets/js/68.4aeeb689.js"><link rel="prefetch" href="/assets/js/69.58b5d893.js"><link rel="prefetch" href="/assets/js/7.2b74ab08.js"><link rel="prefetch" href="/assets/js/70.ab916a91.js"><link rel="prefetch" href="/assets/js/71.44b3dc4f.js"><link rel="prefetch" href="/assets/js/72.ce0608db.js"><link rel="prefetch" href="/assets/js/73.18528fe8.js"><link rel="prefetch" href="/assets/js/74.2b634d9d.js"><link rel="prefetch" href="/assets/js/75.0655e183.js"><link rel="prefetch" href="/assets/js/76.967caf97.js"><link rel="prefetch" href="/assets/js/77.7f8460af.js"><link rel="prefetch" href="/assets/js/78.24bd6824.js"><link rel="prefetch" href="/assets/js/79.dd7efbbf.js"><link rel="prefetch" href="/assets/js/8.65ce892c.js"><link rel="prefetch" href="/assets/js/80.8ecd58d1.js"><link rel="prefetch" href="/assets/js/81.e6963236.js"><link rel="prefetch" href="/assets/js/82.73ac9ee3.js"><link rel="prefetch" href="/assets/js/83.6714b1d0.js"><link rel="prefetch" href="/assets/js/84.c04671b9.js"><link rel="prefetch" href="/assets/js/85.a5064e46.js"><link rel="prefetch" href="/assets/js/86.8207ef25.js"><link rel="prefetch" href="/assets/js/87.8fda855c.js"><link rel="prefetch" href="/assets/js/88.e9f8592a.js"><link rel="prefetch" href="/assets/js/89.647bdc7b.js"><link rel="prefetch" href="/assets/js/9.b68cc135.js"><link rel="prefetch" href="/assets/js/90.97941095.js"><link rel="prefetch" href="/assets/js/91.0f4fde85.js"><link rel="prefetch" href="/assets/js/92.e8d1f6dc.js"><link rel="prefetch" href="/assets/js/93.2596127c.js"><link rel="prefetch" href="/assets/js/94.9bb9c945.js"><link rel="prefetch" href="/assets/js/95.abd0ee19.js"><link rel="prefetch" href="/assets/js/96.9efaa3e5.js"><link rel="prefetch" href="/assets/js/97.bbcd0e98.js"><link rel="prefetch" href="/assets/js/98.d74a45ef.js"><link rel="prefetch" href="/assets/js/99.46f91dc2.js">
    <link rel="stylesheet" href="/assets/css/0.styles.a883148b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar" data-v-9f1e2f90><div data-v-9f1e2f90><div id="loader-wrapper" class="loading-wrapper" data-v-d48f4d20 data-v-9f1e2f90 data-v-9f1e2f90><div class="loader-main" data-v-d48f4d20><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-58d5ab76 data-v-9f1e2f90 data-v-9f1e2f90><h3 class="title" style="display:none;" data-v-58d5ab76 data-v-58d5ab76>十号</h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-58d5ab76 data-v-58d5ab76><input type="password" value="" data-v-58d5ab76> <span data-v-58d5ab76>Konck! Knock!</span> <button data-v-58d5ab76>OK</button></label> <div class="footer" style="display:none;" data-v-58d5ab76 data-v-58d5ab76><span data-v-58d5ab76><i class="iconfont reco-theme" data-v-58d5ab76></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-58d5ab76>vuePress-theme-reco</a></span> <span data-v-58d5ab76><i class="iconfont reco-copyright" data-v-58d5ab76></i> <a data-v-58d5ab76><span data-v-58d5ab76>十号</span>
            
          <!---->
          2022
        </a></span></div></div> <div class="hide" data-v-9f1e2f90><header class="navbar" data-v-9f1e2f90><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">十号</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont undefined"></i>
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/《小狗钱钱》/" class="nav-link"><i class="iconfont undefined"></i>
  《小狗钱钱》
</a></li><li class="dropdown-item"><!----> <a href="/categories/浏览器/" class="nav-link"><i class="iconfont undefined"></i>
  浏览器
</a></li><li class="dropdown-item"><!----> <a href="/categories/Docker/" class="nav-link"><i class="iconfont undefined"></i>
  Docker
</a></li><li class="dropdown-item"><!----> <a href="/categories/note/" class="nav-link"><i class="iconfont undefined"></i>
  note
</a></li><li class="dropdown-item"><!----> <a href="/categories/微前端/" class="nav-link"><i class="iconfont undefined"></i>
  微前端
</a></li><li class="dropdown-item"><!----> <a href="/categories/javascript/" class="nav-link"><i class="iconfont undefined"></i>
  javascript
</a></li><li class="dropdown-item"><!----> <a href="/categories/React/" class="nav-link"><i class="iconfont undefined"></i>
  React
</a></li><li class="dropdown-item"><!----> <a href="/categories/工具/" class="nav-link"><i class="iconfont undefined"></i>
  工具
</a></li><li class="dropdown-item"><!----> <a href="/categories/工具函数/" class="nav-link"><i class="iconfont undefined"></i>
  工具函数
</a></li><li class="dropdown-item"><!----> <a href="/categories/vue/" class="nav-link"><i class="iconfont undefined"></i>
  vue
</a></li></ul></div></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><a href="/about.html" class="nav-link"><i class="iconfont undefined"></i>
  简介
</a></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-9f1e2f90></div> <aside class="sidebar" data-v-9f1e2f90><div class="personal-info-wrapper" data-v-3eba7259 data-v-9f1e2f90><!----> <h3 class="name" data-v-3eba7259>
    十号
  </h3> <div class="num" data-v-3eba7259><div data-v-3eba7259><h3 data-v-3eba7259>20</h3> <h6 data-v-3eba7259>Article</h6></div> <div data-v-3eba7259><h3 data-v-3eba7259>19</h3> <h6 data-v-3eba7259>Tag</h6></div></div> <hr data-v-3eba7259></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont undefined"></i>
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/《小狗钱钱》/" class="nav-link"><i class="iconfont undefined"></i>
  《小狗钱钱》
</a></li><li class="dropdown-item"><!----> <a href="/categories/浏览器/" class="nav-link"><i class="iconfont undefined"></i>
  浏览器
</a></li><li class="dropdown-item"><!----> <a href="/categories/Docker/" class="nav-link"><i class="iconfont undefined"></i>
  Docker
</a></li><li class="dropdown-item"><!----> <a href="/categories/note/" class="nav-link"><i class="iconfont undefined"></i>
  note
</a></li><li class="dropdown-item"><!----> <a href="/categories/微前端/" class="nav-link"><i class="iconfont undefined"></i>
  微前端
</a></li><li class="dropdown-item"><!----> <a href="/categories/javascript/" class="nav-link"><i class="iconfont undefined"></i>
  javascript
</a></li><li class="dropdown-item"><!----> <a href="/categories/React/" class="nav-link"><i class="iconfont undefined"></i>
  React
</a></li><li class="dropdown-item"><!----> <a href="/categories/工具/" class="nav-link"><i class="iconfont undefined"></i>
  工具
</a></li><li class="dropdown-item"><!----> <a href="/categories/工具函数/" class="nav-link"><i class="iconfont undefined"></i>
  工具函数
</a></li><li class="dropdown-item"><!----> <a href="/categories/vue/" class="nav-link"><i class="iconfont undefined"></i>
  vue
</a></li></ul></div></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><a href="/about.html" class="nav-link"><i class="iconfont undefined"></i>
  简介
</a></div> <!----></nav> <!----> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-58d5ab76 data-v-9f1e2f90><h3 class="title" style="display:none;" data-v-58d5ab76 data-v-58d5ab76>《数据结构与算法之美》</h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-58d5ab76 data-v-58d5ab76><input type="password" value="" data-v-58d5ab76> <span data-v-58d5ab76>Konck! Knock!</span> <button data-v-58d5ab76>OK</button></label> <div class="footer" style="display:none;" data-v-58d5ab76 data-v-58d5ab76><span data-v-58d5ab76><i class="iconfont reco-theme" data-v-58d5ab76></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-58d5ab76>vuePress-theme-reco</a></span> <span data-v-58d5ab76><i class="iconfont reco-copyright" data-v-58d5ab76></i> <a data-v-58d5ab76><span data-v-58d5ab76>十号</span>
            
          <!---->
          2022
        </a></span></div></div> <div data-v-9f1e2f90><main class="page"><div class="page-title" style="display:none;"><h1 class="title">《数据结构与算法之美》</h1> <div data-v-42458482><i class="iconfont reco-account" data-v-42458482><span data-v-42458482>十号</span></i> <i class="iconfont reco-date" data-v-42458482><span data-v-42458482>2022-10-15</span></i> <!----> <i class="iconfont reco-tag tags" data-v-42458482><span class="tag-item" data-v-42458482>数据结构与算法</span><span class="tag-item" data-v-42458482>荒天帝</span></i></div></div> <div class="content__default"><div class="content__header"></div> <div class="content__default"><h2 id="开篇词-从今天起-跨过-数据结构与算法-这个坎"><a href="#开篇词-从今天起-跨过-数据结构与算法-这个坎" class="header-anchor">#</a> 开篇词 | 从今天起，跨过“数据结构与算法”这个坎</h2> <div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>那些所谓的新技术，核心和本质的东西其实就是当初学的那些知识。</p></div><div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>基础知识就像是一座大楼的地基，它决定了我们的技术高度。而想要快速做出点事情，前提条件一定是基础能力过硬，“内功”要到位。</p></div><div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>人生路上，我们会遇到很多的坎。跨过去，你就可以成长，跨不过去就是困难和停滞。而在后面很长的一段时间里，你都需要为这个困难买单。对于我们技术人来说，更是这样。<strong>既然数据结构和算法这个坎，我们总归是要跨过去的，为什么不是现在呢？</strong></p></div><h2 id="_01-为什么要学习数据结构和算法"><a href="#_01-为什么要学习数据结构和算法" class="header-anchor">#</a> 01 | 为什么要学习数据结构和算法？</h2> <div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>作为业务开发，我们会用到各种框架、中间件和底层系统，比如Spring、RPC框架、消息中间件、Redis等等。在这些基础框架中，一般都柔和了很多基础数据结构和算法的设计思想。</p></div><div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>掌握数据结构和算法，不管对于阅读框架源码，还是理解其背后的设计思想，都是非常有用的。</p></div><div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>掌握了数据结构与算法，你看待问题的深度，解决问题的角度就会完全不一样。</p></div><h2 id="_02-如何抓住重点-系统高效地学习数据结构与算法"><a href="#_02-如何抓住重点-系统高效地学习数据结构与算法" class="header-anchor">#</a> 02 | 如何抓住重点，系统高效地学习数据结构与算法？</h2> <div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>从广义上讲，<strong>数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。</strong></p></div><div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>数据结构是为算法服务的，算法要作用在特定的数据结构之上。因此，我们无法孤立数据结构来讲算法，也无法孤立算法来讲数据结构。</p></div><div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>数据结构是静态的，它只是组织数据的一种方式。如果不在它的基础上操作、构建算法，孤立存在的数据结构就是没用的。</p></div><div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>数据结构与算法的知识点：</p> <details class="custom-block details"><summary>查看图片</summary> <p><img src="https://cdn.jsdelivr.net/gh/AsherSun/image-host/blog-img/913e0ababe43a2d57267df5c5f0832a7.webp" alt="数据结构与算法知识点"></p></details></div><div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>10个数据结构：
数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie数；<br>
10个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。</p></div><h2 id="_03-复杂度分析-上-如何分析统计算法的执行效率和资源消耗"><a href="#_03-复杂度分析-上-如何分析统计算法的执行效率和资源消耗" class="header-anchor">#</a> 03 ｜ 复杂度分析（上）：如何分析统计算法的执行效率和资源消耗？</h2> <div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>数据结构和算法本身解决的是“快”和“省”的问题，即如何让代码运行的更快，如何让代码更省存储空间。所以，执行效率是算法一个非常重要的考量指标。</p></div><div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p><strong>复杂度分析是整个算法学习的精髓，只要掌握了它，数据结构和算法的内容基本上就掌握了一半。</strong></p></div><div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p><strong>事后统计法的局限性：</strong></p> <ul><li>测试结果非常依赖测试环境</li> <li>测试结果受数据规模的影响很大</li></ul></div><h3 id="大o复杂度表示法"><a href="#大o复杂度表示法" class="header-anchor">#</a> 大O复杂度表示法</h3> <div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>估算下这段代码的执行时间：</p> <div class="language-JavaScript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sum <span class="token operator">+=</span> i<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// return sum</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><blockquote><p>我们可以假设每段代码的执行时间都是一样的，为<code>unit_time</code>。在这个假设的基础之上，这段代码的总执行时间是多少？</p></blockquote> <ul><li>第2、3行分别需要1个<code>unit_time</code>时间，公式为：<code>2 * unit_time</code>。</li> <li>第4、5行都运行了n遍，所以第四行是<code>n * unit_time</code>，第五行也是<code>n * unit_time</code>。简化下公式为：<code>（n + n) * unit_time</code>，再简化下公式为：<code>2n * unit_time</code>。</li> <li>所有代码的执行时间T(n)与每行代码的执行次数成正比</li> <li>最后总的执行时间T(n)为：<code>2n * unit_time + 2 * unit_time</code>，简化下公式为：<code>(2n + 2) * unit_time = T(n)</code></li></ul> <p>再来看下这段代码的执行时间：</p> <div class="language-JavaScript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      sum <span class="token operator">+=</span> i <span class="token operator">*</span> j
      <span class="token comment">// sum = sum + i * j</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>我们依旧假设每个语句的执行时间是<code>unit_time</code>。那么这段代码的总执行时间<code>T(n)</code>是？</p> <ul><li>第2、3、4行分别需要1个<code>unit_time</code>时间。公式为：<code>3 * unti_time</code></li> <li>第5、6行分别需要n个<code>unit_time</code>时间。公式为：<code>2n * unit_time</code></li> <li>第7、8行分别需要n个<code>unit_time</code>时间，但是需要执行n遍。公式为：<code>(2n * unit_time) * n</code></li> <li>最后的执行是间：<code>T(n) = 3 * unit_time + 2n * unit_time + 2n * unit_time * n</code></li> <li>公式简化为：<code>(2n + 3) * unit_time + (2n * n) * unit_time</code></li> <li>公式再简化为：<code>(2n + 3 + 2n²) * unit_time</code></li></ul> <blockquote><p>尽管我们不知道<code>unit_time</code>的具体值，但是通过这两段代码执行时间的推导过程，我们可以得到一个非常重要的规律，那就是，<strong>所有代码的执行时间T(n)与每行代码的执行次数成正比。</strong></p></blockquote> <p><strong>我么可以把这个规律总结为一个公式：T(n) = O(f(n))</strong>
这段公式的大概意思为：</p> <ul><li>T(n)表示一段代码执行的总时间</li> <li>n表示数据规模的大小</li> <li>f(n)每行代码执行的次数总和，因为这是一个公式，所以用f(n)来表示。</li> <li>O表示代码的执行时间T(n)与f(n)表达式成正比。</li></ul> <p>所以第一个例子中的<code>Tn = O(2n + 2)</code>。第二个例子中的T(n) = O(2n + 3 + 2n²)。</p> <p>以上就是大O时间复杂度表示法。</p> <blockquote><p>大O时间复杂度实际上并不具体表示代码真正的执行时间，而是表示<strong>代码执行时间随着数据规模增长的变化趋势</strong>，所以，也叫作<strong>渐进时间复杂度</strong>（asymptotic time complexity），简称<strong>时间复杂度</strong>。</p></blockquote> <p>当 n 很大时，你可以把它想象成 10000、100000。<strong>而公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略</strong>。我们只需要记录一个最大量级就可以了，如果用大 O 表示法表示刚讲的那两段代码的时间复杂度，就可以记为：<strong>T(n) = O(n)； T(n) = O(n2)</strong>。</p></div><h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="header-anchor">#</a> 时间复杂度分析</h3> <div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p><strong>只关注循环次数最多的一段代码</strong> <br>
以下代码为例：</p> <div class="language-JavaScript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sum <span class="token operator">+=</span> i<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ul><li>第2、3行代码都是常量级的执行时间，与n的大小无关，所以对于复杂度并没有影响。</li> <li>循环次数最多的是4、5行代码，这两行代码被执行了n次，所以总的时间复杂度就是O(n)</li></ul></div><div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p><strong>加法法则：总复杂度等于量级最大的那段代码的复杂度。</strong><br>
这段代码，试着分析一下时间复杂度</p> <div class="language-JavaScript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">cal</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> sum_1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> p <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token operator">++</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sum_1 <span class="token operator">=</span> sum_1 <span class="token operator">+</span> p<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">let</span> sum_2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> q <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> q <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>q<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sum_2 <span class="token operator">=</span> sum_2 <span class="token operator">+</span> q<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">let</span> sum_3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> 
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      sum_3 <span class="token operator">=</span> sum_3 <span class="token operator">+</span>  i <span class="token operator">*</span> j<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> sum_1 <span class="token operator">+</span> sum_2 <span class="token operator">+</span> sum_3<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p>这段代码分为3部分，分别是sum_1、sum_2、sum_3。我们分析每一部分的时间复杂度，然后把它们放到一块，再取一个量级最大的作为整段代码的复杂度。</p> <blockquote><p>常量的执行时间虽然会对代码的执行时间有很大的影响，但是回到时间复杂度的概念来说，它表示的是一个算法执行效率与数据规模增长的变化趋势，所以不管常量的执行时间多大，我们都可忽略掉。因为它本身对趋势的增长并没有影响。</p></blockquote> <ul><li>第一段代码是循环了100次，跟n无关，它是一个常量。最终表示为<code>200 * unit_time</code></li> <li>第二段代码是循环了n次，它是一个变量。所以表示为：<code>2n * unit_time</code>，用大O表示法则为<code>O(n)</code></li> <li>第三段代码是外层循环了n次，内层循环了n次的n遍。最终表示为：<code>2n² * unit_time</code>，用大O表示法则为<code>O(n)</code></li> <li>综合这三段代码的时间复杂度，我们取其中最大的量级。所以整段代码的时间复杂度为：<code>O(n²)</code></li></ul> <p>也就是说，<strong>总的时间复杂度等于量级最大的那段代码的时间复杂度</strong>。那么将这个规律抽象成公式就是：<br></p> <p>如果<code>T1(n) = O(f1(n))，T2(n) = O(f2(n))</code>;那么<code>T(n) = T1(n) + T2(n) = max(O(f1(n)), O(f2(n))) = O(max(f1(n), f2(n)))</code>;</p></div><div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p><strong>乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</strong><br>
乘法法则公式：<br></p> <ul><li>如果<code>T1(n) = O(f(n)), T2(n) = O(g(n))</code>；</li> <li>那么<code>T(n) = T1(n) * T2(n) = O(f(n)) * O(g(n)) = O(f(n) * g(n))</code></li></ul> <p>假设：T1(n) = O(n)，T2(n) = O(n²)，那么 T1(n) * T2(n) = O(n²)。落实到具体代码上，可以把乘法法则看成是<strong>嵌套循环</strong>。如下列子：</p> <div class="language-JavaScript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">cal</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ret <span class="token operator">=</span> ret <span class="token operator">*</span> <span class="token function">f</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sum <span class="token operator">+=</span> i<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><ul><li>假设f只是一个普通的操作，那么第4 ~ 6行的时间复杂度就是T1(n) = O(n)。</li> <li>但f不是一个普通操作，f函数里面有一个for循环，所以它的时间复杂度是T2(n) = O(n)</li> <li>那么整个cal函数的时间复杂度就是T1(n) * T2(n) = O(n*n) = O(n²)。</li></ul></div><h3 id="几种常见时间复杂度实例分析"><a href="#几种常见时间复杂度实例分析" class="header-anchor">#</a> 几种常见时间复杂度实例分析</h3> <div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p><img src="https://cdn.jsdelivr.net/gh/AsherSun/image-host/blog-img/3723793cc5c810e9d5b06bc95325bf0a.webp" alt="数据结构与算法知识点">
复杂度量级可以粗略地分为两类</p> <ul><li>多项式量级</li> <li>非多项式量级</li> <li>非多多项式量级只有两个：O(2n) 和 O(n!)。</li></ul> <p>我们把时间复杂度为非多项式量级的算法问题叫作 NP（Non-Deterministic Polynomial，非确定多项式）问题。<br>
当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，非多项式时间复杂度的算法其实是非常低效的算法。</p></div><div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p><strong>1. O(1)</strong><br>
O(1)只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。例如一下代码的时间复杂度就是O(1)。</p> <div class="language-JavaScript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> i <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> j <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> sum <span class="token operator">=</span> i <span class="token operator">+</span> j<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><blockquote><p>只要代码的执行时间不随着n的增大而增长，这样代码的时间复杂度我们都记作O(1)。或者说：<strong>一般情况下，只要算法中不存在循环语句、递归语句、即使有成千上万行代码，其时间复杂度也是O(1)。</strong></p></blockquote></div><div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p><strong>O(logn)、O(nlog)n</strong><br>
如下代码：</p> <div class="language-JavaScript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  i <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li>从代码中可以看出，变量i的值是从1开始，每循环一次乘以2</li> <li>当大于n时循环结束</li> <li>实际上，变量i的取值就是一个等比数列，大致可以表示为2^x = n</li> <li>通过2^x = n求解x，那么可以表示为 x=log2n</li> <li>所以这段代码的时间复杂度就是O(log2n)</li></ul> <p>实际上，不管是以2为底，以3为底，还是以10为底我们都可以把所有对数阶的时间复杂度都记为O(logn)。</p> <p>为什么呢？<br>
我们知道，对数之间是可以互相转换的，log3n 就等于 log32 * log2n，所以 O(log3n) = O(C * log2n)，其中 C=log32 是一个常量。基于我们前面的一个理论：<strong>在采用大 O 标记复杂度的时候，可以忽略系数，即 O(Cf(n)) = O(f(n))</strong>。所以，O(log2n) 就等于 O(log3n)。因此，在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为 O(logn)。<br></p> <p>如果你理解了我前面讲的 O(logn)，那 O(nlogn) 就很容易理解了。还记得我们刚讲的乘法法则吗？如果一段代码的时间复杂度是 O(logn)，我们循环执行 n 遍，时间复杂度就是 O(nlogn) 了。而且，O(nlogn) 也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是 O(nlogn)。</p></div><div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p><strong>O(m+n)、O(m*n)</strong><br>
代码复杂度由两个数据规模决定，如下代码：</p> <div class="language-JavaScript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">cal</span><span class="token punctuation">(</span><span class="token parameter">m<span class="token punctuation">,</span> n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> sum_1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sum_1 <span class="token operator">=</span> sum_1 <span class="token operator">+</span> i<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">let</span> sum_2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sum_2 <span class="token operator">=</span> sum_2 <span class="token operator">+</span> j<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> sum_1 <span class="token operator">+</span> sum_2<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>从代码中可以看出，m 和 n 是表示两个数据规模。我们无法事先评估 m 和 n 谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是 O(m+n)。<br>
针对这种情况，原来的加法法则就不正确了，我们需要将加法规则改为：T1(m) + T2(n) = O(f(m) + g(n))。但是乘法法则继续有效：T1(m)*T2(n) = O(f(m) * f(n))。</p></div><h3 id="空间复杂度分析"><a href="#空间复杂度分析" class="header-anchor">#</a> 空间复杂度分析</h3> <div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>时间复杂度的全称是<strong>渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系</strong>。类比一下，空间复杂度全称就是<strong>渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。</strong></p></div><div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>以代码为例：</p> <div class="language-JavaScript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">*</span> i<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ul><li>从代码中看，第二行申请了一个存储变量i的空间。但它是常量阶的，跟数据规模n没有关系，可以忽略</li> <li>第三行申请了一个大小为n的数组空间，除此之外，剩下的代码都没有占用更多的空间。</li> <li>整段代码的空间复杂度就是O(n)</li></ul> <p>我们常见的空间复杂度就是O(1)、O(n)、O(n²)，像O(logn)、O(nlogn)这样的对数阶复杂度平时都用不到。</p></div><h2 id="_04-复杂度分析-下-浅析最好、最坏、平均、均摊时间复杂度"><a href="#_04-复杂度分析-下-浅析最好、最坏、平均、均摊时间复杂度" class="header-anchor">#</a> 04 | 复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度</h2> <div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>4个复杂度分析概念：</p> <ul><li>最好情况时间复杂度（best case time complexity）</li> <li>最坏情况时间复杂度（worst case time complexity）</li> <li>平均情况时间复杂度（average case time complexity）</li> <li>均摊时间复杂度（amortized time complexity）</li></ul></div><h3 id="最好、最坏情况时间复杂度"><a href="#最好、最坏情况时间复杂度" class="header-anchor">#</a> 最好、最坏情况时间复杂度</h3> <div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>试着分析下这段代码的复杂度</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">// n表示数组array的长度</span>
<span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> x<span class="token punctuation">)</span> pos <span class="token operator">=</span> i<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> pos<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><ul><li>这段代码的负载读是O(n)，其中，n代表数组长度。<br></li></ul> <p>我们来优化下这段代码</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">// n表示数组array的长度</span>
<span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       pos <span class="token operator">=</span> i<span class="token punctuation">;</span>
       <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> pos<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>那么优化完之后的代码时间复杂度还是O(n)吗？用O(n)无法解决。<br></p> <ul><li>因为变量x可能出现在数组的任意位置。</li> <li>如果数组中的第一个元素正好是x变量，时间复杂度就是O(1)。</li> <li>如果数组中不存在x变量，那么就需要将数组遍历一遍，时间复杂度就是O(n)</li> <li>所以，在不同的情况下，这段代码的时间复杂度是不一样的。</li></ul> <p>为了代码表示在不同情况下的不同时间复杂度，这里引入三个概念：<br></p> <p><strong>最好时间复杂度</strong>：在最理想的情况下，执行这段代码的时间复杂度。<br></p> <p><strong>最坏时间复杂度</strong>：在最糟糕的情况下，执行这段代码的时间复杂度。<br></p> <p><strong>平均情况时间复杂度</strong></p></div><h3 id="平均情况时间复杂度"><a href="#平均情况时间复杂度" class="header-anchor">#</a> 平均情况时间复杂度</h3> <div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>我们都知道，最好情况时间复杂度和最坏情况时间复杂度对应的都是极端情况下的代码复杂度，发生的概率其实并不大。为了更好地表示平均情况下的复杂度，我们需要引入另一个概念：平均情况时间复杂度，后面我简称为平均时间复杂度。<br></p> <p>平均时间复杂度又该怎么分析呢？我还是借助刚才查找变量 x 的例子来给你解释。<br></p> <p>要查找的变量 x 在数组中的位置，有 n+1 种情况：在数组的 0～n-1 位置中和不在数组中。我们把每种情况下，查找需要遍历的元素个数累加起来，然后再除以 n+1，就可以得到需要遍历的元素个数的平均值，即：<br></p> <p><img src="https://cdn.jsdelivr.net/gh/AsherSun/image-host/blog-img/d889a358b8eccc5bbb90fc16e327a22f.webp" alt="图片"></p> <p>我们知道，时间复杂度的大 O 标记法中，可以省略掉系数、低阶、常量，所以，咱们把刚刚这个公式简化之后，得到的平均时间复杂度就是 O(n)。<br></p> <p>这个结论虽然是正确的，但是计算过程稍微有点儿问题。究竟是什么问题呢？我们刚讲的这 n+1 种情况，出现的概率并不是一样的。我带你具体分析一下。（这里要稍微用到一点儿概率论的知识，不过非常简单，你不用担心。）<br></p> <p>我们知道，要查找的变量 x，要么在数组里，要么就不在数组里。这两种情况对应的概率统计起来很麻烦，为了方便你理解，我们假设在数组中与不在数组中的概率都为 1/2。另外，要查找的数据出现在 0～n-1 这 n 个位置的概率也是一样的，为 1/n。所以，根据概率乘法法则，要查找的数据出现在 0～n-1 中任意位置的概率就是 1/(2n)。<br></p> <p>因此，前面的推导过程中存在的最大问题就是，没有将各种情况发生的概率考虑进去。如果我们把每种情况发生的概率也考虑进去，那平均时间复杂度的计算过程就变成了这样：<br> <img src="https://cdn.jsdelivr.net/gh/AsherSun/image-host/blog-img/36c0aabdac69032f8a43368f5e90c67f.webp" alt="图片">
这个值就是概率论中的加权平均值，也叫作期望值，所以平均时间复杂度的全称应该叫加权平均时间复杂度或者期望时间复杂度。<br></p> <p>引入概率之后，前面那段代码的加权平均值为 (3n+1)/4。用大 O 表示法来表示，去掉系数和常量，这段代码的加权平均时间复杂度仍然是 O(n)。<br></p> <p>你可能会说，平均时间复杂度分析好复杂啊，还要涉及概率论的知识。实际上，在大多数情况下，我们并不需要区分最好、最坏、平均情况时间复杂度三种情况。像我们上一节课举的那些例子那样，很多时候，我们使用一个复杂度就可以满足需求了。只有同一块代码在不同的情况下，时间复杂度有量级的差距，我们才会使用这三种复杂度表示法来区分。<br></p></div><h3 id="均摊时间复杂度"><a href="#均摊时间复杂度" class="header-anchor">#</a> 均摊时间复杂度</h3> <div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>每一次O(n)的插入操作，都会跟着n-1次O(1)的插入操作，所以把耗时多的那次操作均摊到接下来 n - 1次耗时的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是O(1)。</p></div><div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>均摊时间复杂度就是一种特殊的平均时间复杂度。</p></div><h2 id="_05-数组-为什么很多编程语言中数组都是从0开始编号"><a href="#_05-数组-为什么很多编程语言中数组都是从0开始编号" class="header-anchor">#</a> 05 | 数组：为什么很多编程语言中数组都是从0开始编号？</h2> <h3 id="如何实现随机访问"><a href="#如何实现随机访问" class="header-anchor">#</a> 如何实现随机访问</h3> <div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>数组的定义：<br></p> <ul><li><strong>数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。</strong></li></ul></div><div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>线性表（Linear List）：<br>
线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。除了数组，链表、队列、栈等也是线性表结构。</p> <details class="custom-block details"><summary>查看图片</summary> <p><img src="https://cdn.jsdelivr.net/gh/AsherSun/image-host/blog-img/b6b71ec46935130dff5c4b62cf273477.webp" alt="线性表"></p></details></div><div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>非线性表：<br>
在非线性表中，数据之间并不是简单的前后关系。比如，二叉树、堆、图等。</p> <details class="custom-block details"><summary>查看图片</summary> <p><img src="https://cdn.jsdelivr.net/gh/AsherSun/image-host/blog-img/6ebf42641b5f98f912d36f6bf86f6569.webp" alt="非线性表"></p></details></div><div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>数组的线性表特性加上连续的内存空间和相同类型的数据确保了数组的“随机访问特性”。弊端是让数组的另一些操作变得非常低效，比如数组中的删除、插入一个数据，为保证连续性，就需要做大量的数据搬移工作。</p></div><div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>计算机随机访问数组中的某个元素时，会通过下面的寻址公式，计算出该元素存储的内存地址：</p> <div class="language-base line-numbers-mode"><pre class="language-text"><code>a[i]_adddress = base_address + i + data_type_size
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>其中data_type_size表示数组中每个元素的大小</p></div><div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>数组适合查找，但时间复杂度并不为O(1)。即便是排序号的数组，使用二分查找，时间复杂度也是O(logn)。数组支持随机访问，根据下标随机访问的时间复杂度为O(1)。</p></div><h3 id="低效的-插入-和-删除"><a href="#低效的-插入-和-删除" class="header-anchor">#</a> 低效的“插入”和“删除”</h3> <div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p><strong>插入操作</strong><br></p> <ul><li>如果只插入到数组末尾，那么时间复杂度是O(1)</li> <li>如果插入到数组开头，那么时间复杂度是O(n)</li> <li>在每个位置上插入的概率是一样的，那么平均情况时间复杂度为(1 + 2 + ...n) / n = O(n)</li> <li>如果数组中的数据是无序的，只是一个存储数据的集合。在这种情况下，为了避免大规模的迁移数据，通常会在插入的位置把改位置的元素移动到最后一位，然后再插入。这时候时间复杂度为O(1)。</li></ul></div><div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p><strong>删除操作</strong><br></p> <ul><li>如果只删除数组末尾的数据，那么时间复杂度是O(1)</li> <li>如果删除数组开头的疏忽，那么时间复杂度为O(n)，平均情况时间复杂度也为O(n)</li></ul> <p>如果在不追求数组中数据连续性的情况下，可以将多次的删除操作标记出来，等到数组没有更多的存储空间时，再触发一次真正的删除操作，这时就大大减少了删除操作导致的数据搬移。
例如，数组中存储了8个元素：a、b、c、d、e、f、g、h。现在依次删除a、b、c三个元素。
<img src="https://cdn.jsdelivr.net/gh/AsherSun/image-host/blog-img/b69b8c5dbf6248649ddab7d3e7cfd7e5.webp" alt="非线性表">
为避免多次搬移数据，先记录已删除的数据。当数组没有更多存储空间时，再触发一次真正的删除操作。</p></div><h3 id="警惕数组的访问越界问题"><a href="#警惕数组的访问越界问题" class="header-anchor">#</a> 警惕数组的访问越界问题</h3> <div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>先看一段C语言代码：</p> <div class="language-C line-numbers-mode"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span><span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;hello world\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>这段代码会无限循环打印Hello world。<br></p> <p>因为数组大小为3，<code>a[0]、a[1]、a[2]</code>。for循环的结束条件写成了<code>i&lt;= 3</code>，所以，当<code>i = 3</code> 时，数组<code>a[3]</code>访问越界。正确的方式是for循环结束条件写成 <code>i &lt; 3</code>。<br></p> <p>在C语言中，只要不是访问受限的内存，所有的内存空间都可以自由访问。根据前面讲的数组寻址公式，<code>a[3]</code>会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量i的内存地址。那么<code>a[3] = 0</code>，其实就是变量<code>i = 0</code>，所以会导致代码无限循环。<br></p> <p>并非所有的编程语言都像C这样，像JavaScript本身并不存在数组访问越界的问题，因为JavaScript中的数组通常而言是不会定义它的大小，而是动态扩容的。<br></p></div><h3 id="二维数组内存寻址"><a href="#二维数组内存寻址" class="header-anchor">#</a> 二维数组内存寻址</h3> <div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>对于 <code>m * n</code> 的数组，<code>a [ i ][ j ] (i &lt; m,j &lt; n)</code>的地址为：</p> <p><code>address = base_address + ( i * n + j) * type_size</code></p></div><h2 id="_06-链表-上-如何实现lru缓存淘汰算法"><a href="#_06-链表-上-如何实现lru缓存淘汰算法" class="header-anchor">#</a> 06 | 链表（上）：如何实现LRU缓存淘汰算法？</h2> <div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>常见的三种缓存策略：</p> <ul><li>先进先出策略FIFO（Fist In，Fist Out）</li> <li>最少使用策略LFU（Least Frequently Used）</li> <li>最近最少使用策略（Least Recently Used）</li></ul></div><h3 id="五花八门的链表结构"><a href="#五花八门的链表结构" class="header-anchor">#</a> 五花八门的链表结构</h3> <div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p><strong>底层的存储结构</strong><br>
数组需要一块<strong>连续的内存空间</strong>来存储，对内存的要求比较高。如果申请一个100MB大小的数组，当内存中没有连续的、足够大的存储空间时，即便内存的剩余总可以用空间大于100MB，仍然会申请失败。</p> <p>链表并不需要一块连续的内存空间，它通过“指针”将一组零散的内存块串联起来使用。所以，如果我们申请的是100MB大小的链表，根本不会有问题。</p> <p><img src="https://cdn.jsdelivr.net/gh/AsherSun/image-host/blog-img/d5d5bee4be28326ba3c28373808a62cd.webp" alt="数组和链表的存储结构"></p></div><div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>常见的三种链表结构<br></p> <ul><li>单链表</li> <li>双链表</li> <li>循环链表</li></ul></div><div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>链表通过指针将一组零散的内存块串联在一起。其中，我们把内存块成为链表的<strong>结点</strong>。为了将所有节点串联起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址。我们把这个记录下个结点的指针叫做<strong>后继指针</strong>。</p> <p><img src="https://cdn.jsdelivr.net/gh/AsherSun/image-host/blog-img/b93e7ade9bb927baad1348d9a806ddeb.webp" alt="单链表"></p> <p>我们习惯把第一个结点叫做头结点，把最后一个结点叫做尾结点。头结点用来记录链表的基地址。有了它，我们就可以遍历整条链表。而尾结点指向一个<strong>空地址NULL</strong>，表示这是链表上的最后一个结点。</p></div><div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>针对链表的插入和删除操作，我们只需要考虑相邻结点的指针改变，所以对应的时间复杂度是O(1)。
<img src="https://cdn.jsdelivr.net/gh/AsherSun/image-host/blog-img/452e943788bdeea462d364389bd08a17.webp" alt="链表的插入或删除"></p> <p>如果想要随机访问第K个元素，就没有数组那么高效了。因为链表中的数据并非连续存储的，所以无法像数组那样，根据首地址和下标，通过寻址公式就能直接计算出对应的内存地址，而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点。</p> <p>你可以把链表想象成一个队伍，队伍中的每个人都只知道自己后面的人是谁，所以当我们希望知道排在第 k 位的人是谁的时候，我们就需要从第一个人开始，一个一个地往下数。所以，链表随机访问的性能没有数组好，需要 O(n) 的时间复杂度。</p></div><div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p><strong>循环链表是一种特殊的单链表</strong>。它跟单链表唯一的区别就在尾结点。循环链表的尾结点指针是指向链表的头结点。</p> <p><img src="https://cdn.jsdelivr.net/gh/AsherSun/image-host/blog-img/86cb7dc331ea958b0a108b911f38d155.webp" alt="循环链表"></p> <p>循环链表的优点是从链尾到链头比较方便。当要处理的数据具有环型结构特点时，就特别适合采用循环链表。比如著名的<a href="https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%91%9F%E5%A4%AB%E6%96%AF%E9%97%AE%E9%A2%98" target="_blank" rel="noopener noreferrer">约瑟夫问题<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p></div><div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p><strong>双向链表</strong><br>
单向链表只有一个方向，结点只有一个后继指针 next 指向后面的结点。而双向链表，顾名思义，它支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。</p> <p><img src="https://cdn.jsdelivr.net/gh/AsherSun/image-host/blog-img/cbc8ab20276e2f9312030c313a9ef70b.webp" alt="循环链表"></p> <p>双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。所以，如果存储同样多的数据，双向链表要比单链表占用更多的内存空间。虽然两个指针比较浪费存储空间，但可以支持双向遍历，这样也带来了双向链表操作的灵活性。</p> <p>从结构上来看，双向链表可以支持 O(1) 时间复杂度的情况下找到前驱结点，正是这样的特点，也使双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效。</p></div><div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p><strong>删除操作</strong><br>
在实际的软件开发中，从链表中删除一个数据无外乎这两种情况：</p> <ul><li>删除结点中“值等于某个给定值”的结点；</li> <li>删除给定指针指向的结点。</li></ul> <p>尽管单纯的删除操作时间复杂度是 O(1)，但遍历查找的时间是主要的耗时点，对应的时间复杂度为 O(n)。根据时间复杂度分析中的加法法则，删除值等于给定值的结点对应的链表操作的总时间复杂度为 O(n)。</p> <p>我们已经找到了要删除的结点，但是删除某个结点 q 需要知道其前驱结点，而单链表并不支持直接获取前驱结点，所以，为了找到前驱结点，我们还是要从头结点开始遍历链表，直到 p-&gt;next=q，说明 p 是 q 的前驱结点。</p> <p>所以，针对第二种情况，单链表删除操作需要 O(n) 的时间复杂度，而双向链表只需要在 O(1) 的时间复杂度内就搞定了！</p> <p>对于一个有序链表，双向链表的按值查询的效率也要比单链表高一些。因为，我们可以记录上次查找的位置 p，每次查询时，根据要查找的值与 p 的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。</p></div><div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p><strong>空间换时间的设计思想</strong><br></p> <p>当内存空间充足的时候，如果我们更加追求代码的执行速度，我们就可以选择空间复杂度相对较高、但时间复杂度相对很低的算法或者数据结构。相反，如果内存比较紧缺，比如代码跑在手机或者单片机上，这个时候，就要反过来用时间换空间的设计思路。</p> <p>对于执行较慢的程序，可以通过消耗更多的内存（空间换时间）来进行优化；而消耗过多内存的程序，可以通过消耗更多的时间（时间换空间）来降低内存的消耗。</p></div><div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p><strong>双向循环列表</strong> <img src="https://cdn.jsdelivr.net/gh/AsherSun/image-host/blog-img/d1665043b283ecdf79b157cfc9e5ed91.webp" alt="双向循环列表"></p></div><h3 id="链表-vs-数组性能大比拼"><a href="#链表-vs-数组性能大比拼" class="header-anchor">#</a> 链表 VS 数组性能大比拼</h3> <div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>数组和链表是两种截然不同的内存组织方式。正是因为内存存储的区别，它们插入、删除、随机访问操作的时间复杂度正好相反。
<img src="https://cdn.jsdelivr.net/gh/AsherSun/image-host/blog-img/4f63e92598ec2551069a0eef69db7168.webp" alt="链表和数组的性能"></p></div><h3 id="如何基于链表实现lru缓存淘汰算法"><a href="#如何基于链表实现lru缓存淘汰算法" class="header-anchor">#</a> 如何基于链表实现LRU缓存淘汰算法？</h3> <div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。</p> <ol><li><p>如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。</p></li> <li><p>如果此数据没有在缓存链表中，又可以分为两种情况：</p></li></ol> <ul><li>如果此时缓存未满，则将此结点直接插入到链表的头部；</li> <li>如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。</li></ul> <p>因为不管缓存有没有满，我们都需要遍历一遍链表，所以这种基于链表的实现思路，缓存访问的时间复杂度为 O(n)。</p> <p>实际上，我们可以继续优化这个实现思路，比如引入散列表（Hash table）来记录每个数据的位置，将缓存访问的时间复杂度降到 O(1)。</p></div><h2 id="_07-链表-下-如何轻松写出正确的链表代码"><a href="#_07-链表-下-如何轻松写出正确的链表代码" class="header-anchor">#</a> 07 | 链表（下）：如何轻松写出正确的链表代码？</h2> <h3 id="技巧一-理解指针或引用的含义"><a href="#技巧一-理解指针或引用的含义" class="header-anchor">#</a> 技巧一：理解指针或引用的含义</h3> <div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>有些语言有“指针”的概念，比如C语言；有些语言没有指针，取而代之的是“引用”，比如Java、Python。不管是“指针”还是“引用”，实际上，它们的意思都是一样的，都是存储所指对象的内存地址。</p></div><div class="note-block"><svg t="1665301607231" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4678" width="200" height="200" class="icon" style="width:20px;height:20px;"><path d="M512 469.333333m-426.666667 0a426.666667 426.666667 0 1 0 853.333334 0 426.666667 426.666667 0 1 0-853.333334 0Z" fill="#FFF59D" p-id="4679"></path><path d="M789.333333 469.333333c0-164.266667-140.8-294.4-309.333333-275.2-128 14.933333-230.4 117.333333-243.2 245.333334-10.666667 98.133333 29.866667 185.6 98.133333 241.066666 29.866667 25.6 49.066667 61.866667 49.066667 102.4v6.4h256v-2.133333c0-38.4 17.066667-76.8 46.933333-102.4 61.866667-51.2 102.4-128 102.4-215.466667z" fill="#FBC02D" p-id="4680"></path><path d="M652.8 430.933333l-64-42.666666c-6.4-4.266667-17.066667-4.266667-23.466667 0L512 422.4l-51.2-34.133333c-6.4-4.266667-17.066667-4.266667-23.466667 0l-64 42.666666c-4.266667 4.266667-8.533333 8.533333-8.533333 14.933334s0 12.8 4.266667 17.066666l81.066666 100.266667V789.333333h42.666667V554.666667c0-4.266667-2.133333-8.533333-4.266667-12.8l-70.4-87.466667 32-21.333333 51.2 34.133333c6.4 4.266667 17.066667 4.266667 23.466667 0l51.2-34.133333 32 21.333333-70.4 87.466667c-2.133333 4.266667-4.266667 8.533333-4.266667 12.8v234.666666h42.666667V563.2l81.066667-100.266667c4.266667-4.266667 6.4-10.666667 4.266666-17.066666s-4.266667-12.8-8.533333-14.933334z" fill="#FFF59D" p-id="4681"></path><path d="M512 938.666667m-64 0a64 64 0 1 0 128 0 64 64 0 1 0-128 0Z" fill="#5C6BC0" p-id="4682"></path><path d="M554.666667 960h-85.333334c-46.933333 0-85.333333-38.4-85.333333-85.333333v-106.666667h256v106.666667c0 46.933333-38.4 85.333333-85.333333 85.333333z" fill="#9FA8DA" p-id="4683"></path><path d="M640 874.666667l-247.466667 34.133333c6.4 14.933333 19.2 29.866667 34.133334 38.4l200.533333-27.733333c8.533333-12.8 12.8-27.733333 12.8-44.8zM384 825.6v42.666667L640 832v-42.666667z" fill="#5C6BC0" p-id="4684"></path></svg> <style>
          blockquote {
            background-color: var(--code-color);
            border-color: #67cc86;
            border-left-width: 0.5rem;
            border-left-style: solid;
          }
        </style><p>指针的概念</p> <blockquote><p>将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。</p></blockquote></div><div class="note-block"><svg t="1665301607231" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4678" width="200" height="200" class="icon" style="width:20px;height:20px;"><path d="M512 469.333333m-426.666667 0a426.666667 426.666667 0 1 0 853.333334 0 426.666667 426.666667 0 1 0-853.333334 0Z" fill="#FFF59D" p-id="4679"></path><path d="M789.333333 469.333333c0-164.266667-140.8-294.4-309.333333-275.2-128 14.933333-230.4 117.333333-243.2 245.333334-10.666667 98.133333 29.866667 185.6 98.133333 241.066666 29.866667 25.6 49.066667 61.866667 49.066667 102.4v6.4h256v-2.133333c0-38.4 17.066667-76.8 46.933333-102.4 61.866667-51.2 102.4-128 102.4-215.466667z" fill="#FBC02D" p-id="4680"></path><path d="M652.8 430.933333l-64-42.666666c-6.4-4.266667-17.066667-4.266667-23.466667 0L512 422.4l-51.2-34.133333c-6.4-4.266667-17.066667-4.266667-23.466667 0l-64 42.666666c-4.266667 4.266667-8.533333 8.533333-8.533333 14.933334s0 12.8 4.266667 17.066666l81.066666 100.266667V789.333333h42.666667V554.666667c0-4.266667-2.133333-8.533333-4.266667-12.8l-70.4-87.466667 32-21.333333 51.2 34.133333c6.4 4.266667 17.066667 4.266667 23.466667 0l51.2-34.133333 32 21.333333-70.4 87.466667c-2.133333 4.266667-4.266667 8.533333-4.266667 12.8v234.666666h42.666667V563.2l81.066667-100.266667c4.266667-4.266667 6.4-10.666667 4.266666-17.066666s-4.266667-12.8-8.533333-14.933334z" fill="#FFF59D" p-id="4681"></path><path d="M512 938.666667m-64 0a64 64 0 1 0 128 0 64 64 0 1 0-128 0Z" fill="#5C6BC0" p-id="4682"></path><path d="M554.666667 960h-85.333334c-46.933333 0-85.333333-38.4-85.333333-85.333333v-106.666667h256v106.666667c0 46.933333-38.4 85.333333-85.333333 85.333333z" fill="#9FA8DA" p-id="4683"></path><path d="M640 874.666667l-247.466667 34.133333c6.4 14.933333 19.2 29.866667 34.133334 38.4l200.533333-27.733333c8.533333-12.8 12.8-27.733333 12.8-44.8zM384 825.6v42.666667L640 832v-42.666667z" fill="#5C6BC0" p-id="4684"></path></svg> <style>
          blockquote {
            background-color: var(--code-color);
            border-color: #67cc86;
            border-left-width: 0.5rem;
            border-left-style: solid;
          }
        </style><p>理解链表</p> <blockquote><p><code>p-&gt;next=q</code>。这个代码是说，p节点中的next指针存储了q结点的内存地址。<br> <code>p-&gt;next=p-&gt;next-&gt;next</code>。这行代码表示，p结点的next指针存储了p节点的下下一个结点的内存地址。</p></blockquote></div><h3 id="技巧二-警惕指针丢失和内存泄露"><a href="#技巧二-警惕指针丢失和内存泄露" class="header-anchor">#</a> 技巧二：警惕指针丢失和内存泄露</h3> <div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p><img src="https://cdn.jsdelivr.net/gh/AsherSun/image-host/blog-img/05a4a3b57502968930d517c934347c6e.webp" alt="单链表插入">
如图所示，我们希望在结点 a 和相邻的结点 b 之间插入结点 x，假设当前指针 p 指向结点 a。如果我们将代码实现变成下面这个样子，就会发生指针丢失和内存泄露。</p> <div class="language-base line-numbers-mode"><pre class="language-text"><code>p-&gt;next = x;  // 将p的next指针指向x结点；
x-&gt;next = p-&gt;next;  // 将x的结点的next指针指向b结点；
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>p-next指针在完成第一步操作之后，已经不再指向结点b，而是指向结点x。第2行代码相当于将x赋值给x-next，自己指向自己。因此，整个链表也就段按成了两半，从结点b往后的所有结点都无法访问到了。</p> <p>对于有些语言来说，比如 C 语言，内存管理是由程序员负责的，如果没有手动释放结点对应的内存空间，就会产生内存泄露。所以，我们插入结点时，一定要注意操作的顺序，要先将结点 x 的 next 指针指向结点 b，再把结点 a 的 next 指针指向结点 x，这样才不会丢失指针，导致内存泄漏。</p> <p>同理，删除链表结点时，也一定要记得手动释放内存空间，否则，也会出现内存泄漏的问题。</p></div><h3 id="技巧三-利用哨兵简化实现难度"><a href="#技巧三-利用哨兵简化实现难度" class="header-anchor">#</a> 技巧三：利用哨兵简化实现难度</h3> <div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>如果向一个空链表中插入第一个结点，需要这样处理</p> <div class="language-Java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  head <span class="token operator">=</span> new_node<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>如果删除链表中最后一个结点，需要写成这样子</p> <div class="language-Java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token operator">-&gt;</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   head <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>我们可以看出，针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理。这样代码实现起来就会很繁琐，不简洁，而且也容易因为考虑不全而出错。</p> <p>如果我们引入哨兵结点，在任何时候，不管链表是不是空，head 指针都会一直指向这个哨兵结点。我们也把这种有哨兵结点的链表叫带头链表。相反，没有哨兵结点的链表就叫作不带头链表。
<img src="https://cdn.jsdelivr.net/gh/AsherSun/image-host/blog-img/7d22d9428bdbba96bfe388fe1e3368c7.webp" alt="单链表插入">
利用哨兵简化编程难度的技巧，在很多代码实现中都有用到，比如插入排序，归并排序，动态规划等。</p></div><div class="note-block"><svg t="1665301607231" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4678" width="200" height="200" class="icon" style="width:20px;height:20px;"><path d="M512 469.333333m-426.666667 0a426.666667 426.666667 0 1 0 853.333334 0 426.666667 426.666667 0 1 0-853.333334 0Z" fill="#FFF59D" p-id="4679"></path><path d="M789.333333 469.333333c0-164.266667-140.8-294.4-309.333333-275.2-128 14.933333-230.4 117.333333-243.2 245.333334-10.666667 98.133333 29.866667 185.6 98.133333 241.066666 29.866667 25.6 49.066667 61.866667 49.066667 102.4v6.4h256v-2.133333c0-38.4 17.066667-76.8 46.933333-102.4 61.866667-51.2 102.4-128 102.4-215.466667z" fill="#FBC02D" p-id="4680"></path><path d="M652.8 430.933333l-64-42.666666c-6.4-4.266667-17.066667-4.266667-23.466667 0L512 422.4l-51.2-34.133333c-6.4-4.266667-17.066667-4.266667-23.466667 0l-64 42.666666c-4.266667 4.266667-8.533333 8.533333-8.533333 14.933334s0 12.8 4.266667 17.066666l81.066666 100.266667V789.333333h42.666667V554.666667c0-4.266667-2.133333-8.533333-4.266667-12.8l-70.4-87.466667 32-21.333333 51.2 34.133333c6.4 4.266667 17.066667 4.266667 23.466667 0l51.2-34.133333 32 21.333333-70.4 87.466667c-2.133333 4.266667-4.266667 8.533333-4.266667 12.8v234.666666h42.666667V563.2l81.066667-100.266667c4.266667-4.266667 6.4-10.666667 4.266666-17.066666s-4.266667-12.8-8.533333-14.933334z" fill="#FFF59D" p-id="4681"></path><path d="M512 938.666667m-64 0a64 64 0 1 0 128 0 64 64 0 1 0-128 0Z" fill="#5C6BC0" p-id="4682"></path><path d="M554.666667 960h-85.333334c-46.933333 0-85.333333-38.4-85.333333-85.333333v-106.666667h256v106.666667c0 46.933333-38.4 85.333333-85.333333 85.333333z" fill="#9FA8DA" p-id="4683"></path><path d="M640 874.666667l-247.466667 34.133333c6.4 14.933333 19.2 29.866667 34.133334 38.4l200.533333-27.733333c8.533333-12.8 12.8-27.733333 12.8-44.8zM384 825.6v42.666667L640 832v-42.666667z" fill="#5C6BC0" p-id="4684"></path></svg> <style>
          blockquote {
            background-color: var(--code-color);
            border-color: #67cc86;
            border-left-width: 0.5rem;
            border-left-style: solid;
          }
        </style><p>哨兵机制的代码举例：<br>
代码一：</p> <div class="language-C line-numbers-mode"><pre class="language-c"><code><span class="token comment">// 在数组a中，查找key，返回key所在的位置</span>
<span class="token comment">// 其中，n表示数组a的长度</span>
<span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">char</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 边界条件处理，如果a为空，或者n&lt;=0，说明数组中没有数据，就不用while循环比较了</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">==</span> null <span class="token operator">||</span> n <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token comment">// 这里有两个比较操作：i&lt;n和a[i]==key.</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token operator">++</span>i<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>代码二：</p> <div class="language-C line-numbers-mode"><pre class="language-c"><code><span class="token comment">// 在数组a中，查找key，返回key所在的位置</span>
<span class="token comment">// 其中，n表示数组a的长度</span>
<span class="token comment">// 我举2个例子，你可以拿例子走一下代码</span>
<span class="token comment">// a = {4, 2, 3, 5, 9, 6}  n=6 key = 7</span>
<span class="token comment">// a = {4, 2, 3, 5, 9, 6}  n=6 key = 6</span>
<span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">char</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">==</span> null <span class="token operator">||</span> n <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  <span class="token comment">// 这里因为要将a[n-1]的值替换成key，所以要特殊处理这个值</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  <span class="token comment">// 把a[n-1]的值临时保存在变量tmp中，以便之后恢复。tmp=6。</span>
  <span class="token comment">// 之所以这样做的目的是：希望find()代码不要改变a数组中的内容</span>
  <span class="token keyword">char</span> tmp <span class="token operator">=</span> a<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token comment">// 把key的值放到a[n-1]中，此时a = {4, 2, 3, 5, 9, 7}</span>
  a<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span>
  
  <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token comment">// while 循环比起代码一，少了i&lt;n这个比较操作</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">++</span>i<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  <span class="token comment">// 恢复a[n-1]原来的值,此时a= {4, 2, 3, 5, 9, 6}</span>
  a<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
  
  <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果i == n-1说明，在0...n-2之间都没有key，所以返回-1</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 否则，返回i，就是等于key值的元素的下标</span>
    <span class="token keyword">return</span> i<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br></div></div><p>对比两段代码，在字符串 a 很长的时候，比如几万、几十万，你觉得哪段代码运行得更快点呢？答案是代码二，因为两段代码中执行次数最多就是 while 循环那一部分。第二段代码中，我们通过一个哨兵 a[n-1] = key，成功省掉了一个比较语句<code>i&lt;n</code>，不要小看这一条语句，当累积执行万次、几十万次时，累积的时间就很明显了。</p> <p>当然，这只是为了举例说明哨兵的作用，你写代码的时候千万不要写第二段那样的代码，因为可读性太差了。大部分情况下，我们并不需要如此追求极致的性能。</p></div><h3 id="技巧四-重点留意边界条件处理"><a href="#技巧四-重点留意边界条件处理" class="header-anchor">#</a> 技巧四：重点留意边界条件处理</h3> <div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>检查链表代码是否正确的边界条件有这样几个：</p> <ul><li>如果链表为空时，代码是否能正常工作？</li> <li>如果链表只包含一个结点时，代码是否能正常工作？</li> <li>如果链表只包含两个结点时，代码是否能正常工作？</li> <li>代码逻辑在处理头结点和尾结点的时候偶，是否能正常工作？</li></ul> <p>边界条件不止我列举的那些。针对不同的场景，可能还有特定的边界条件，这个需要你自己去思考，不过套路都是一样的。</p> <p>实际上，不光光是写链表代码，你在写任何代码时，也千万不要只是实现业务正常情况下的功能就好了，一定要多想想，你的代码在运行的时候，可能会遇到哪些边界情况或者异常情况。遇到了应该如何应对，这样写出来的代码才够健壮！</p></div><h3 id="技巧五-举例画图-辅助思考"><a href="#技巧五-举例画图-辅助思考" class="header-anchor">#</a> 技巧五：举例画图，辅助思考</h3> <div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>举例法和画图法</p> <p>比如往单链表中插入一个数据这样一个操作，我一般都是把各种情况都举一个例子，画出插入前和插入后的链表变化，如图所示：</p> <p><img src="https://cdn.jsdelivr.net/gh/AsherSun/image-host/blog-img/4a701dd79b59427be654261805b349f8.webp" alt="举例画图法"></p> <p>看图写代码，是不是就简单多啦？而且，当我们写完代码之后，也可以举几个例子，画在纸上，照着代码走一遍，很容易就能发现代码中的 Bug。</p></div><h3 id="技巧六-多写多练-没有捷径"><a href="#技巧六-多写多练-没有捷径" class="header-anchor">#</a> 技巧六：多写多练，没有捷径</h3> <div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>5个常见的链表操作</p> <ul><li>单链表反转</li> <li>链表中环的检测</li> <li>两个有序的链表合并</li> <li>删除链表倒数第n个结点</li> <li>求链表的中间结点</li></ul> <p>把这几个操作都能写熟练，不熟就多写几遍</p></div><h2 id="_08-栈-如何实现浏览器的前进和后退功能"><a href="#_08-栈-如何实现浏览器的前进和后退功能" class="header-anchor">#</a> 08 | 栈：如何实现浏览器的前进和后退功能？</h2> <h3 id="如何理解-栈"><a href="#如何理解-栈" class="header-anchor">#</a> 如何理解“栈”？</h3> <div class="note-block"><svg t="1665301607231" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4678" width="200" height="200" class="icon" style="width:20px;height:20px;"><path d="M512 469.333333m-426.666667 0a426.666667 426.666667 0 1 0 853.333334 0 426.666667 426.666667 0 1 0-853.333334 0Z" fill="#FFF59D" p-id="4679"></path><path d="M789.333333 469.333333c0-164.266667-140.8-294.4-309.333333-275.2-128 14.933333-230.4 117.333333-243.2 245.333334-10.666667 98.133333 29.866667 185.6 98.133333 241.066666 29.866667 25.6 49.066667 61.866667 49.066667 102.4v6.4h256v-2.133333c0-38.4 17.066667-76.8 46.933333-102.4 61.866667-51.2 102.4-128 102.4-215.466667z" fill="#FBC02D" p-id="4680"></path><path d="M652.8 430.933333l-64-42.666666c-6.4-4.266667-17.066667-4.266667-23.466667 0L512 422.4l-51.2-34.133333c-6.4-4.266667-17.066667-4.266667-23.466667 0l-64 42.666666c-4.266667 4.266667-8.533333 8.533333-8.533333 14.933334s0 12.8 4.266667 17.066666l81.066666 100.266667V789.333333h42.666667V554.666667c0-4.266667-2.133333-8.533333-4.266667-12.8l-70.4-87.466667 32-21.333333 51.2 34.133333c6.4 4.266667 17.066667 4.266667 23.466667 0l51.2-34.133333 32 21.333333-70.4 87.466667c-2.133333 4.266667-4.266667 8.533333-4.266667 12.8v234.666666h42.666667V563.2l81.066667-100.266667c4.266667-4.266667 6.4-10.666667 4.266666-17.066666s-4.266667-12.8-8.533333-14.933334z" fill="#FFF59D" p-id="4681"></path><path d="M512 938.666667m-64 0a64 64 0 1 0 128 0 64 64 0 1 0-128 0Z" fill="#5C6BC0" p-id="4682"></path><path d="M554.666667 960h-85.333334c-46.933333 0-85.333333-38.4-85.333333-85.333333v-106.666667h256v106.666667c0 46.933333-38.4 85.333333-85.333333 85.333333z" fill="#9FA8DA" p-id="4683"></path><path d="M640 874.666667l-247.466667 34.133333c6.4 14.933333 19.2 29.866667 34.133334 38.4l200.533333-27.733333c8.533333-12.8 12.8-27.733333 12.8-44.8zM384 825.6v42.666667L640 832v-42.666667z" fill="#5C6BC0" p-id="4684"></path></svg> <style>
          blockquote {
            background-color: var(--code-color);
            border-color: #67cc86;
            border-left-width: 0.5rem;
            border-left-style: solid;
          }
        </style><p>栈概念</p> <blockquote><p>后进者先出，先进者后出，这就是典型的“栈”结构<br>
从栈的操作特性上来看，栈是一种“操作受限”的线性表，只允许在一端插入和删除数据。</p></blockquote></div><div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>事实上，从功能上来说，数组或链表确实可以替代栈，但你要知道，特定的数据结构是对特定场景的抽象，而且，数组或链表暴露了太多的操作接口，操作上的确灵活自由，但使用时就比较不可控，自然也就更容易出错。</p> <p><strong>当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，这时我们就应该首选“栈”这种数据结构。</strong></p></div><h3 id="如何实现一个-栈"><a href="#如何实现一个-栈" class="header-anchor">#</a> 如何实现一个“栈”？</h3> <div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>实际上，栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，我们叫作<strong>顺序栈</strong>，用链表实现的栈，我们叫作<strong>链式栈</strong>。</p></div><div class="note-block"><svg t="1665301607231" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4678" width="200" height="200" class="icon" style="width:20px;height:20px;"><path d="M512 469.333333m-426.666667 0a426.666667 426.666667 0 1 0 853.333334 0 426.666667 426.666667 0 1 0-853.333334 0Z" fill="#FFF59D" p-id="4679"></path><path d="M789.333333 469.333333c0-164.266667-140.8-294.4-309.333333-275.2-128 14.933333-230.4 117.333333-243.2 245.333334-10.666667 98.133333 29.866667 185.6 98.133333 241.066666 29.866667 25.6 49.066667 61.866667 49.066667 102.4v6.4h256v-2.133333c0-38.4 17.066667-76.8 46.933333-102.4 61.866667-51.2 102.4-128 102.4-215.466667z" fill="#FBC02D" p-id="4680"></path><path d="M652.8 430.933333l-64-42.666666c-6.4-4.266667-17.066667-4.266667-23.466667 0L512 422.4l-51.2-34.133333c-6.4-4.266667-17.066667-4.266667-23.466667 0l-64 42.666666c-4.266667 4.266667-8.533333 8.533333-8.533333 14.933334s0 12.8 4.266667 17.066666l81.066666 100.266667V789.333333h42.666667V554.666667c0-4.266667-2.133333-8.533333-4.266667-12.8l-70.4-87.466667 32-21.333333 51.2 34.133333c6.4 4.266667 17.066667 4.266667 23.466667 0l51.2-34.133333 32 21.333333-70.4 87.466667c-2.133333 4.266667-4.266667 8.533333-4.266667 12.8v234.666666h42.666667V563.2l81.066667-100.266667c4.266667-4.266667 6.4-10.666667 4.266666-17.066666s-4.266667-12.8-8.533333-14.933334z" fill="#FFF59D" p-id="4681"></path><path d="M512 938.666667m-64 0a64 64 0 1 0 128 0 64 64 0 1 0-128 0Z" fill="#5C6BC0" p-id="4682"></path><path d="M554.666667 960h-85.333334c-46.933333 0-85.333333-38.4-85.333333-85.333333v-106.666667h256v106.666667c0 46.933333-38.4 85.333333-85.333333 85.333333z" fill="#9FA8DA" p-id="4683"></path><path d="M640 874.666667l-247.466667 34.133333c6.4 14.933333 19.2 29.866667 34.133334 38.4l200.533333-27.733333c8.533333-12.8 12.8-27.733333 12.8-44.8zM384 825.6v42.666667L640 832v-42.666667z" fill="#5C6BC0" p-id="4684"></path></svg> <style>
          blockquote {
            background-color: var(--code-color);
            border-color: #67cc86;
            border-left-width: 0.5rem;
            border-left-style: solid;
          }
        </style><p>基于数组的顺序栈</p> <div class="language-Java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 基于数组实现的顺序栈</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayStack</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> items<span class="token punctuation">;</span>  <span class="token comment">// 数组</span>
  <span class="token keyword">private</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>       <span class="token comment">// 栈中元素个数</span>
  <span class="token keyword">private</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span>           <span class="token comment">//栈的大小</span>

  <span class="token comment">// 初始化数组，申请一个大小为n的数组空间</span>
  <span class="token keyword">public</span> <span class="token class-name">ArrayStack</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>items <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>n <span class="token operator">=</span> n<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 入栈操作</span>
  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token class-name">String</span> item<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 数组空间不够了，直接返回false，入栈失败。</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token comment">// 将item放到下标为count的位置，并且count加一</span>
    items<span class="token punctuation">[</span>count<span class="token punctuation">]</span> <span class="token operator">=</span> item<span class="token punctuation">;</span>
    <span class="token operator">++</span>count<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  <span class="token comment">// 出栈操作</span>
  <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 栈为空，则直接返回null</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token comment">// 返回下标为count-1的数组元素，并且栈中元素个数count减一</span>
    <span class="token class-name">String</span> tmp <span class="token operator">=</span> items<span class="token punctuation">[</span>count<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token operator">--</span>count<span class="token punctuation">;</span>
    <span class="token keyword">return</span> tmp<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br></div></div><ul><li>栈的空间复杂度为O(1)</li> <li>栈的时间复杂度为O(1)</li></ul></div><h3 id="支持动态扩容的顺序栈"><a href="#支持动态扩容的顺序栈" class="header-anchor">#</a> 支持动态扩容的顺序栈</h3> <div class="note-block"><svg t="1665301607231" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4678" width="200" height="200" class="icon" style="width:20px;height:20px;"><path d="M512 469.333333m-426.666667 0a426.666667 426.666667 0 1 0 853.333334 0 426.666667 426.666667 0 1 0-853.333334 0Z" fill="#FFF59D" p-id="4679"></path><path d="M789.333333 469.333333c0-164.266667-140.8-294.4-309.333333-275.2-128 14.933333-230.4 117.333333-243.2 245.333334-10.666667 98.133333 29.866667 185.6 98.133333 241.066666 29.866667 25.6 49.066667 61.866667 49.066667 102.4v6.4h256v-2.133333c0-38.4 17.066667-76.8 46.933333-102.4 61.866667-51.2 102.4-128 102.4-215.466667z" fill="#FBC02D" p-id="4680"></path><path d="M652.8 430.933333l-64-42.666666c-6.4-4.266667-17.066667-4.266667-23.466667 0L512 422.4l-51.2-34.133333c-6.4-4.266667-17.066667-4.266667-23.466667 0l-64 42.666666c-4.266667 4.266667-8.533333 8.533333-8.533333 14.933334s0 12.8 4.266667 17.066666l81.066666 100.266667V789.333333h42.666667V554.666667c0-4.266667-2.133333-8.533333-4.266667-12.8l-70.4-87.466667 32-21.333333 51.2 34.133333c6.4 4.266667 17.066667 4.266667 23.466667 0l51.2-34.133333 32 21.333333-70.4 87.466667c-2.133333 4.266667-4.266667 8.533333-4.266667 12.8v234.666666h42.666667V563.2l81.066667-100.266667c4.266667-4.266667 6.4-10.666667 4.266666-17.066666s-4.266667-12.8-8.533333-14.933334z" fill="#FFF59D" p-id="4681"></path><path d="M512 938.666667m-64 0a64 64 0 1 0 128 0 64 64 0 1 0-128 0Z" fill="#5C6BC0" p-id="4682"></path><path d="M554.666667 960h-85.333334c-46.933333 0-85.333333-38.4-85.333333-85.333333v-106.666667h256v106.666667c0 46.933333-38.4 85.333333-85.333333 85.333333z" fill="#9FA8DA" p-id="4683"></path><path d="M640 874.666667l-247.466667 34.133333c6.4 14.933333 19.2 29.866667 34.133334 38.4l200.533333-27.733333c8.533333-12.8 12.8-27.733333 12.8-44.8zM384 825.6v42.666667L640 832v-42.666667z" fill="#5C6BC0" p-id="4684"></path></svg> <style>
          blockquote {
            background-color: var(--code-color);
            border-color: #67cc86;
            border-left-width: 0.5rem;
            border-left-style: solid;
          }
        </style><p>动态扩容的栈的示意图</p> <p><img src="https://cdn.jsdelivr.net/gh/AsherSun/image-host/blog-img/b193adf5db4356d8ab35a1d32142b3da.webp" alt="动态扩容的栈"></p> <ul><li>出栈的时间复杂度始终不变，为O(1)</li> <li>入栈，当栈申请的内存足够时，时间复杂度为O(1)</li> <li>入栈，当栈需要扩容时，时间复杂度为O(n)</li></ul> <p>对于入栈操作来说，最好情况时间复杂度是O(1)，最坏情况时间复杂度是O(n)。那么入栈的平均时间复杂度是多少？</p> <p>为了方便分析，需要事先做一些假设和分析：</p> <ul><li>栈空间不够时，我们重新申请一个是原来大小两倍的数组；</li> <li>为了简化分析，假设只有入栈操作没有出栈操作；</li> <li>定义不涉及内存搬移的入栈操作为simple-push操作，时间复杂度为O(1)</li></ul> <p>如果当前栈大小为 K，并且已满，当再有新的数据要入栈时，就需要重新申请 2 倍大小的内存，并且做 K 个数据的搬移操作，然后再入栈。但是，接下来的 K-1 次入栈操作，我们都不需要再重新申请内存和搬移数据，所以这 K-1 次入栈操作都只需要一个 simple-push 操作就可以完成。为了让你更加直观地理解这个过程，请看下面这张图。</p> <p><img src="https://cdn.jsdelivr.net/gh/AsherSun/image-host/blog-img/c936a39ad54a9fdf526e805dc18cf6bb.webp" alt="入栈的时间复杂度"></p> <p>这 K 次入栈操作，总共涉及了 K 个数据的搬移，以及 K 次 simple-push 操作。将 K 个数据搬移均摊到 K 次入栈操作，那每个入栈操作只需要一个数据搬移和一个 simple-push 操作。以此类推，入栈操作的均摊时间复杂度就为 O(1)。</p> <p>通过这个例子的实战分析，也印证了前面讲到的，均摊时间复杂度一般都等于最好情况时间复杂度。因为在大部分情况下，入栈操作的时间复杂度 O 都是 O(1)，只有在个别时刻才会退化为 O(n)，所以把耗时多的入栈操作的时间均摊到其他入栈操作上，平均情况下的耗时就接近 O(1)。</p></div><h3 id="栈在函数调用中的应用"><a href="#栈在函数调用中的应用" class="header-anchor">#</a> 栈在函数调用中的应用</h3> <div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构, 用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。为了更好地理解，看下这段代码的执行过程。</p> <div class="language-C line-numbers-mode"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> 
   <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
   <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
   ret <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   res <span class="token operator">=</span> a <span class="token operator">+</span> ret<span class="token punctuation">;</span>
   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d&quot;</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>
   reuturn <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
   sum <span class="token operator">=</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
   <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>上述代码中对应的函数栈里出栈、入栈的操作，如图所示</p> <p><img src="https://cdn.jsdelivr.net/gh/AsherSun/image-host/blog-img/17b6c6711e8d60b61d65fb0df5559a1c.webp" alt="函数调用栈"></p></div><h3 id="栈在表达式求值中的应用"><a href="#栈在表达式求值中的应用" class="header-anchor">#</a> 栈在表达式求值中的应用</h3> <div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>编译器如何利用栈来实现<strong>表达式求值</strong></p> <p>比如一个简单的四则运算：<code>34+13*9+44-12/3</code></p> <p>编译器通过两个栈来实现，其中一个保存操作数的栈，另一个是保存运算符的栈。从左向右遍历表达式，当遇到数字，就压入操作数栈；当遇到运算符，就与运算符栈顶元素进行比较。</p> <p>如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。</p> <p>我们将<code>3+5*8-6</code>这个表达式的计算过程画成一张图</p> <p><img src="https://cdn.jsdelivr.net/gh/AsherSun/image-host/blog-img/bc77c8d33375750f1700eb7778551600.webp" alt="利用栈来实现表达式求值"></p></div><h3 id="栈在括号匹配中的应用"><a href="#栈在括号匹配中的应用" class="header-anchor">#</a> 栈在括号匹配中的应用</h3> <div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>假设表达式中只包含三种括号：<code>()</code>、<code>[]</code>、<code>{}</code>，并且它们可以任意嵌套。</p> <p>我们用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，比如“(”跟“)”匹配，“[”跟“]”匹配，“{”跟“}”匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。</p> <p>当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明有未匹配的左括号，为非法格式。</p></div><h3 id="浏览器前进、后退功能的实现"><a href="#浏览器前进、后退功能的实现" class="header-anchor">#</a> 浏览器前进、后退功能的实现</h3> <div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>我们使用两个栈，X 和 Y，我们把首次浏览的页面依次压入栈 X，当点击后退按钮时，再依次从栈 X 中出栈，并将出栈的数据依次放入栈 Y。当我们点击前进按钮时，我们依次从栈 Y 中取出数据，放入栈 X 中。当栈 X 中没有数据时，那就说明没有页面可以继续后退浏览了。当栈 Y 中没有数据，那就说明没有页面可以点击前进按钮浏览了。</p> <p>比如你顺序查看了 a，b，c 三个页面，我们就依次把 a，b，c 压入栈，这个时候，两个栈的数据就是这个样子：
<img src="https://cdn.jsdelivr.net/gh/AsherSun/image-host/blog-img/4b579a76ea7ebfc5abae2ad6ae6a3c3d.webp" alt=""></p> <p>当你通过浏览器的后退按钮，从页面 c 后退到页面 a 之后，我们就依次把 c 和 b 从栈 X 中弹出，并且依次放入到栈 Y。这个时候，两个栈的数据就是这个样子：</p> <p><img src="https://cdn.jsdelivr.net/gh/AsherSun/image-host/blog-img/b5e496e2e28fe08f0388958a0e12861b.webp" alt=""></p> <p>这个时候你又想看页面 b，于是你又点击前进按钮回到 b 页面，我们就把 b 再从栈 Y 中出栈，放入栈 X 中。此时两个栈的数据是这个样子：</p> <p><img src="https://cdn.jsdelivr.net/gh/AsherSun/image-host/blog-img/ea804125bea25d25ba467a51fb98c4bc.webp" alt=""></p> <p>这个时候，你通过页面 b 又跳转到新的页面 d 了，页面 c 就无法再通过前进、后退按钮重复查看了，所以需要清空栈 Y。此时两个栈的数据这个样子：</p> <p><img src="https://cdn.jsdelivr.net/gh/AsherSun/image-host/blog-img/a3c926fe3050d9a741f394f20430692e.webp" alt=""></p></div><h2 id="_09-队列-队列在线程池等有限资源池中的应用"><a href="#_09-队列-队列在线程池等有限资源池中的应用" class="header-anchor">#</a> 09 | 队列：队列在线程池等有限资源池中的应用</h2> <h3 id="如何理解队列"><a href="#如何理解队列" class="header-anchor">#</a> 如何理解队列？</h3> <div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>先进者先出，这就是典型的“队列”。</p> <p>栈只有两个基本操作：<strong>入栈push()和出栈pop()</strong>。队列跟栈非常相似，支持的操作也很有限，最基本的操作也是两个：<strong>入队enqueue()</strong>，放一个数据到队列尾部：<strong>出队dequeue()，从队列头部取一个元素</strong>。</p> <p><img src="https://cdn.jsdelivr.net/gh/AsherSun/image-host/blog-img/9eca53f9b557b1213c5d94b94e9dce3e.webp" alt="队列和栈"></p> <p>所以，队列跟栈一样，也是一种<strong>操作受限的线性表数据结构</strong>。</p></div><div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>作为一种非常基础的数据结构，队列的应用也非常广泛，特别是一些具有某些额外特性的队列，比如循环队列、阻塞队列、并发队列。它们在很多偏底层系统、框架、中间件的开发中，起着关键性的作用。比如高性能队列Disruptor、Linux环形缓存，都用到了循环并发队列；</p></div><h3 id="顺序队列和链式队列"><a href="#顺序队列和链式队列" class="header-anchor">#</a> 顺序队列和链式队列</h3> <div class="note-block"><svg t="1665301607231" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4678" width="200" height="200" class="icon" style="width:20px;height:20px;"><path d="M512 469.333333m-426.666667 0a426.666667 426.666667 0 1 0 853.333334 0 426.666667 426.666667 0 1 0-853.333334 0Z" fill="#FFF59D" p-id="4679"></path><path d="M789.333333 469.333333c0-164.266667-140.8-294.4-309.333333-275.2-128 14.933333-230.4 117.333333-243.2 245.333334-10.666667 98.133333 29.866667 185.6 98.133333 241.066666 29.866667 25.6 49.066667 61.866667 49.066667 102.4v6.4h256v-2.133333c0-38.4 17.066667-76.8 46.933333-102.4 61.866667-51.2 102.4-128 102.4-215.466667z" fill="#FBC02D" p-id="4680"></path><path d="M652.8 430.933333l-64-42.666666c-6.4-4.266667-17.066667-4.266667-23.466667 0L512 422.4l-51.2-34.133333c-6.4-4.266667-17.066667-4.266667-23.466667 0l-64 42.666666c-4.266667 4.266667-8.533333 8.533333-8.533333 14.933334s0 12.8 4.266667 17.066666l81.066666 100.266667V789.333333h42.666667V554.666667c0-4.266667-2.133333-8.533333-4.266667-12.8l-70.4-87.466667 32-21.333333 51.2 34.133333c6.4 4.266667 17.066667 4.266667 23.466667 0l51.2-34.133333 32 21.333333-70.4 87.466667c-2.133333 4.266667-4.266667 8.533333-4.266667 12.8v234.666666h42.666667V563.2l81.066667-100.266667c4.266667-4.266667 6.4-10.666667 4.266666-17.066666s-4.266667-12.8-8.533333-14.933334z" fill="#FFF59D" p-id="4681"></path><path d="M512 938.666667m-64 0a64 64 0 1 0 128 0 64 64 0 1 0-128 0Z" fill="#5C6BC0" p-id="4682"></path><path d="M554.666667 960h-85.333334c-46.933333 0-85.333333-38.4-85.333333-85.333333v-106.666667h256v106.666667c0 46.933333-38.4 85.333333-85.333333 85.333333z" fill="#9FA8DA" p-id="4683"></path><path d="M640 874.666667l-247.466667 34.133333c6.4 14.933333 19.2 29.866667 34.133334 38.4l200.533333-27.733333c8.533333-12.8 12.8-27.733333 12.8-44.8zM384 825.6v42.666667L640 832v-42.666667z" fill="#5C6BC0" p-id="4684"></path></svg> <style>
          blockquote {
            background-color: var(--code-color);
            border-color: #67cc86;
            border-left-width: 0.5rem;
            border-left-style: solid;
          }
        </style><p>队列的实现方式</p> <blockquote><p>跟栈一样，队列可以用数组来实现，也可以用链表来实现。用数组实现的栈叫作顺序栈，用链表实现的栈叫作链式栈。同样，用数组实现的队列叫作<strong>顺序队列</strong>，用链表实现的队列叫作<strong>链式队列</strong>。</p></blockquote></div><div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>基于数组实现的队列</p> <div class="language-Java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 用数组实现的队列</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayQueue</span> <span class="token punctuation">{</span>
  <span class="token comment">// 数组：items，数组大小：n</span>
  <span class="token keyword">private</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> items<span class="token punctuation">;</span>
  <span class="token keyword">private</span> <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token comment">// head表示队头下标，tail表示队尾下标</span>
  <span class="token keyword">private</span> <span class="token keyword">int</span> head <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">private</span> <span class="token keyword">int</span> tail <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

  <span class="token comment">// 申请一个大小为capacity的数组</span>
  <span class="token keyword">public</span> <span class="token class-name">ArrayQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    items <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span>capacity<span class="token punctuation">]</span><span class="token punctuation">;</span>
    n <span class="token operator">=</span> capacity<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 入队</span>
  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token class-name">String</span> item<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果tail == n 表示队列已经满了</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>tail <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    items<span class="token punctuation">[</span>tail<span class="token punctuation">]</span> <span class="token operator">=</span> item<span class="token punctuation">;</span>
    <span class="token operator">++</span>tail<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 出队</span>
  <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果head == tail 表示队列为空</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> tail<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token comment">// 为了让其他语言的同学看的更加明确，把--操作放到单独一行来写了</span>
    <span class="token class-name">String</span> ret <span class="token operator">=</span> items<span class="token punctuation">[</span>head<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token operator">++</span>head<span class="token punctuation">;</span>
    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br></div></div><p>对于栈来说，我们只需要一个栈顶指针就可以了。但是队列需要两个指针：一个是 head 指针，指向队头；一个是 tail 指针，指向队尾。</p> <p>结合下面这张图来理解。当 a、b、c、d 依次入队之后，队列中的 head 指针指向下标为 0 的位置，tail 指针指向下标为 4 的位置。</p> <p><img src="https://cdn.jsdelivr.net/gh/AsherSun/image-host/blog-img/5c0ec42eb797e8a7d48c9dbe89dc93cb.webp" alt="队列示意图"></p> <p>当我们调用两次出队操作之后，队列中 head 指针指向下标为 2 的位置，tail 指针仍然指向下标为 4 的位置。</p> <p><img src="https://cdn.jsdelivr.net/gh/AsherSun/image-host/blog-img/dea27f2c505dd8d0b6b86e262d03430d.webp" alt="出队操作"></p> <p>根据图片的示意，随着不停地进行入队、出队操作，head和tail斗殴会持续往后移动。当tail移动到最右边，即使数组中还有空闲空间，也无法继续往队列中添加数据了。</p> <p>解决这个问题需要用到<strong>数据搬移！</strong>。但是每次进行出队操作都相当于删除数组下标为0的数据，需要搬移整个队列中的数据，这样出队操作的时间复杂度就会从原来的O(1)变为O(n)。</p> <p>实际上，可以不用在每次出队时都搬移数据。如果没有空闲空间了，我们只需要在入队时，再集中触发一次数据的搬移操作。</p> <p>下面是具体的代码：</p> <div class="language-Java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 入队操作，将item放入队尾</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token class-name">String</span> item<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// tail == n表示队列末尾没有空间了</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>tail <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// tail ==n &amp;&amp; head==0，表示整个队列都占满了</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token comment">// 数据搬移</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> head<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> tail<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      items<span class="token punctuation">[</span>i<span class="token operator">-</span>head<span class="token punctuation">]</span> <span class="token operator">=</span> items<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 搬移完之后重新更新head和tail</span>
    tail <span class="token operator">-=</span> head<span class="token punctuation">;</span>
    head <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  items<span class="token punctuation">[</span>tail<span class="token punctuation">]</span> <span class="token operator">=</span> item<span class="token punctuation">;</span>
  <span class="token operator">++</span>tail<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>从代码中，我们可以将head到tail之间的数据，整体搬移到数组中 0 到tail-head的位置。</p> <p><img src="https://cdn.jsdelivr.net/gh/AsherSun/image-host/blog-img/094ba7722eeec46ead58b40c097353c7.webp" alt="队列中数据搬移"></p> <p>这种情况下，出队的时间复杂度为O(1)。入队的时间复杂度最好情况下是O(1)，最坏情况下是O(n)，平均时间复杂度是O(1)。</p></div><div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>基于链表的队列实现方法</p> <p>基于链表的实现，我们同样需要两个指针：head 指针和 tail 指针。它们分别指向链表的第一个结点和最后一个结点。如图所示，入队时，tail-&gt;next= new_node, tail = tail-&gt;next；出队时，head = head-&gt;next。</p> <p><img src="https://cdn.jsdelivr.net/gh/AsherSun/image-host/blog-img/c916fe2212f8f543ddf539296444d393.webp" alt="基于链表的队列"></p></div><h3 id="循环队列"><a href="#循环队列" class="header-anchor">#</a> 循环队列</h3> <div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>循环队列可以解决用数据来实现队列存在的数据搬移操作。即：<strong>循环队列可以避免数据搬移</strong>。</p></div><div class="note-block"><svg t="1665301607231" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4678" width="200" height="200" class="icon" style="width:20px;height:20px;"><path d="M512 469.333333m-426.666667 0a426.666667 426.666667 0 1 0 853.333334 0 426.666667 426.666667 0 1 0-853.333334 0Z" fill="#FFF59D" p-id="4679"></path><path d="M789.333333 469.333333c0-164.266667-140.8-294.4-309.333333-275.2-128 14.933333-230.4 117.333333-243.2 245.333334-10.666667 98.133333 29.866667 185.6 98.133333 241.066666 29.866667 25.6 49.066667 61.866667 49.066667 102.4v6.4h256v-2.133333c0-38.4 17.066667-76.8 46.933333-102.4 61.866667-51.2 102.4-128 102.4-215.466667z" fill="#FBC02D" p-id="4680"></path><path d="M652.8 430.933333l-64-42.666666c-6.4-4.266667-17.066667-4.266667-23.466667 0L512 422.4l-51.2-34.133333c-6.4-4.266667-17.066667-4.266667-23.466667 0l-64 42.666666c-4.266667 4.266667-8.533333 8.533333-8.533333 14.933334s0 12.8 4.266667 17.066666l81.066666 100.266667V789.333333h42.666667V554.666667c0-4.266667-2.133333-8.533333-4.266667-12.8l-70.4-87.466667 32-21.333333 51.2 34.133333c6.4 4.266667 17.066667 4.266667 23.466667 0l51.2-34.133333 32 21.333333-70.4 87.466667c-2.133333 4.266667-4.266667 8.533333-4.266667 12.8v234.666666h42.666667V563.2l81.066667-100.266667c4.266667-4.266667 6.4-10.666667 4.266666-17.066666s-4.266667-12.8-8.533333-14.933334z" fill="#FFF59D" p-id="4681"></path><path d="M512 938.666667m-64 0a64 64 0 1 0 128 0 64 64 0 1 0-128 0Z" fill="#5C6BC0" p-id="4682"></path><path d="M554.666667 960h-85.333334c-46.933333 0-85.333333-38.4-85.333333-85.333333v-106.666667h256v106.666667c0 46.933333-38.4 85.333333-85.333333 85.333333z" fill="#9FA8DA" p-id="4683"></path><path d="M640 874.666667l-247.466667 34.133333c6.4 14.933333 19.2 29.866667 34.133334 38.4l200.533333-27.733333c8.533333-12.8 12.8-27.733333 12.8-44.8zM384 825.6v42.666667L640 832v-42.666667z" fill="#5C6BC0" p-id="4684"></path></svg> <style>
          blockquote {
            background-color: var(--code-color);
            border-color: #67cc86;
            border-left-width: 0.5rem;
            border-left-style: solid;
          }
        </style><p>看图，感受下循环队列：</p> <p><img src="https://cdn.jsdelivr.net/gh/AsherSun/image-host/blog-img/58ba37bb4102b87d66dffe7148b0f990.webp" alt="循环队列"></p> <p>图中这个队列的大小为 8，当前 head=4，tail=7。当有一个新的元素 a 入队时，我们放入下标为 7 的位置。但这个时候，我们并不把 tail 更新为 8，而是将其在环中后移一位，到下标为 0 的位置。当再有一个元素 b 入队时，我们将 b 放入下标为 0 的位置，然后 tail 加 1 更新为 1。所以，在 a，b 依次入队之后，循环队列中的元素就变成了下面的样子：</p> <p><img src="https://cdn.jsdelivr.net/gh/AsherSun/image-host/blog-img/71a41effb54ccea9dd463bde1b6abe80.webp" alt="循环队列的入队"></p> <p>通过这样的方法，我们成功避免了数据搬移操作。</p> <p>要想写出没有 bug 的循环队列的实现代码，最关键的是，确定好队空和队满的判定条件。</p></div><div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>循环队列中，判断队列为空的判断条件仍然是 head == tail。但是队列满的判断条件就稍微有点复杂。先看一张队列满的图：</p> <p><img src="https://cdn.jsdelivr.net/gh/AsherSun/image-host/blog-img/3d81a44f8c42b3ceee55605f9aeedcec.webp" alt="循环满队列"></p> <p>就像图中画的队满的情况，tail=3，head=4，n=8，所以总结一下规律就是：(3+1)%8=4。多画几张队满的图，你就会发现，当队满时，(tail+1)%n=head。</p> <p>当队列满时，图中的 tail 指向的位置实际上是没有存储数据的。所以，循环队列会浪费一个数组的存储空间。</p> <p>代码示意：</p> <div class="language-Java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CircularQueue</span> <span class="token punctuation">{</span>
  <span class="token comment">// 数组：items，数组大小：n</span>
  <span class="token keyword">private</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> items<span class="token punctuation">;</span>
  <span class="token keyword">private</span> <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token comment">// head表示队头下标，tail表示队尾下标</span>
  <span class="token keyword">private</span> <span class="token keyword">int</span> head <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">private</span> <span class="token keyword">int</span> tail <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

  <span class="token comment">// 申请一个大小为capacity的数组</span>
  <span class="token keyword">public</span> <span class="token class-name">CircularQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    items <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span>capacity<span class="token punctuation">]</span><span class="token punctuation">;</span>
    n <span class="token operator">=</span> capacity<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 入队</span>
  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token class-name">String</span> item<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 队列满了</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tail <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> n <span class="token operator">==</span> head<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    items<span class="token punctuation">[</span>tail<span class="token punctuation">]</span> <span class="token operator">=</span> item<span class="token punctuation">;</span>
    tail <span class="token operator">=</span> <span class="token punctuation">(</span>tail <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> n<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 出队</span>
  <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果head == tail 表示队列为空</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> tail<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token class-name">String</span> ret <span class="token operator">=</span> items<span class="token punctuation">[</span>head<span class="token punctuation">]</span><span class="token punctuation">;</span>
    head <span class="token operator">=</span> <span class="token punctuation">(</span>head <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> n<span class="token punctuation">;</span>
    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br></div></div></div><h3 id="阻塞队列和并发队列"><a href="#阻塞队列和并发队列" class="header-anchor">#</a> 阻塞队列和并发队列</h3> <div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>阻塞队列和并发队列这种特殊特性的队列应用会比较广泛。</p></div><div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>阻塞队列其实就是在队列基础上增加了阻塞操作。</p> <p>在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。</p> <p><img src="https://cdn.jsdelivr.net/gh/AsherSun/image-host/blog-img/5ef3326181907dea0964f612890185eb.webp" alt="阻塞队列"></p> <p>上述的定义就是一个“生产者 - 消费者模型”！是的，我们可以使用阻塞队列，轻松实现一个“生产者 - 消费者模型”！</p> <p>这种基于阻塞队列实现的“生产者 - 消费者模型”，可以有效地协调生产和消费的速度。当“生产者”生产数据的速度过快，“消费者”来不及消费时，存储数据的队列很快就会满了。这个时候，生产者就阻塞等待，直到“消费者”消费了数据，“生产者”才会被唤醒继续“生产”。</p> <p>而且不仅如此，基于阻塞队列，我们还可以通过协调“生产者”和“消费者”的个数，来提高数据的处理效率。比如前面的例子，我们可以多配置几个“消费者”，来应对一个“生产者”。</p> <p><img src="https://cdn.jsdelivr.net/gh/AsherSun/image-host/blog-img/9f539cc0f1edc20e7fa6559193898067.webp" alt="阻塞队列-生产端多个消费者"></p></div><div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>线程安全的队列我们叫作并发队列。最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。</p></div><h2 id="_10-递归-如何利用三行代码找到-最终推荐人"><a href="#_10-递归-如何利用三行代码找到-最终推荐人" class="header-anchor">#</a> 10 | 递归：如何利用三行代码找到“最终推荐人”？</h2> <div class="note-block"><svg t="1665301607231" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4678" width="200" height="200" class="icon" style="width:20px;height:20px;"><path d="M512 469.333333m-426.666667 0a426.666667 426.666667 0 1 0 853.333334 0 426.666667 426.666667 0 1 0-853.333334 0Z" fill="#FFF59D" p-id="4679"></path><path d="M789.333333 469.333333c0-164.266667-140.8-294.4-309.333333-275.2-128 14.933333-230.4 117.333333-243.2 245.333334-10.666667 98.133333 29.866667 185.6 98.133333 241.066666 29.866667 25.6 49.066667 61.866667 49.066667 102.4v6.4h256v-2.133333c0-38.4 17.066667-76.8 46.933333-102.4 61.866667-51.2 102.4-128 102.4-215.466667z" fill="#FBC02D" p-id="4680"></path><path d="M652.8 430.933333l-64-42.666666c-6.4-4.266667-17.066667-4.266667-23.466667 0L512 422.4l-51.2-34.133333c-6.4-4.266667-17.066667-4.266667-23.466667 0l-64 42.666666c-4.266667 4.266667-8.533333 8.533333-8.533333 14.933334s0 12.8 4.266667 17.066666l81.066666 100.266667V789.333333h42.666667V554.666667c0-4.266667-2.133333-8.533333-4.266667-12.8l-70.4-87.466667 32-21.333333 51.2 34.133333c6.4 4.266667 17.066667 4.266667 23.466667 0l51.2-34.133333 32 21.333333-70.4 87.466667c-2.133333 4.266667-4.266667 8.533333-4.266667 12.8v234.666666h42.666667V563.2l81.066667-100.266667c4.266667-4.266667 6.4-10.666667 4.266666-17.066666s-4.266667-12.8-8.533333-14.933334z" fill="#FFF59D" p-id="4681"></path><path d="M512 938.666667m-64 0a64 64 0 1 0 128 0 64 64 0 1 0-128 0Z" fill="#5C6BC0" p-id="4682"></path><path d="M554.666667 960h-85.333334c-46.933333 0-85.333333-38.4-85.333333-85.333333v-106.666667h256v106.666667c0 46.933333-38.4 85.333333-85.333333 85.333333z" fill="#9FA8DA" p-id="4683"></path><path d="M640 874.666667l-247.466667 34.133333c6.4 14.933333 19.2 29.866667 34.133334 38.4l200.533333-27.733333c8.533333-12.8 12.8-27.733333 12.8-44.8zM384 825.6v42.666667L640 832v-42.666667z" fill="#5C6BC0" p-id="4684"></path></svg> <style>
          blockquote {
            background-color: var(--code-color);
            border-color: #67cc86;
            border-left-width: 0.5rem;
            border-left-style: solid;
          }
        </style><p>如何理解递归？</p> <blockquote><p>去的过程叫“递”，回来的过程叫归。基本上，所有递归问题都可以用递归公式来表示。</p></blockquote> <p>比如，想在电影院中寻找自己在哪一排，可以写成这样的公式：</p> <div class="language-base line-numbers-mode"><pre class="language-text"><code>f(n) = f(n-1)+1
其中，f(1)=1
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>f(n)表示你想知道自己在哪一排，f(n-1)表示前面一排所在的排数，f(1)=1表示第一排的人知道自己在第一排。有了这个公式，可以很轻松写出递归代码：</p> <div class="language-C line-numbers-mode"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></div><h3 id="递归需要满足的三个条件"><a href="#递归需要满足的三个条件" class="header-anchor">#</a> 递归需要满足的三个条件</h3> <div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>只要同时满足这三个条件，就可以用递归来解决。</p> <ol><li>一个问题的解可以分解为几个子问题的解</li></ol> <ul><li>子问题就是数据规模更小的问题。</li></ul> <ol start="2"><li>这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样</li> <li>存在递归终止条件</li></ol></div><h3 id="如何编写递归代码"><a href="#如何编写递归代码" class="header-anchor">#</a> 如何编写递归代码</h3> <div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>写递归代码最关键的是<strong>写出递归公式，找到终止条件</strong>。</p> <p>加入这里有n个台阶，每次你可以跨1个台阶或者2个台阶，请问走这个n个台阶有多少种走法？如果有7个台阶，你可以2，2，2，1走上去，也可以1，2，1，1，2走上去。总之走法有很多，那如何用编程求得总共有多少种走法呢？</p> <p>可以根据第一步的走法把所有走法分为两类，第一类是第一步走了1个台阶，另一类是第一步走了2个台阶。所以n个台阶的走法就等于先走1阶后，n-1个台阶的走法加上先走2阶后，n-2个台阶的走法。用公式表示就是：</p> <div class="language-base line-numbers-mode"><pre class="language-text"><code>f(n) = f(n-1)+f(n-2)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>递归终止条件是f(1)=1，f(2)=2。</p> <p>把递归终止条件和刚刚得到的公式放在一起是这样的：</p> <div class="language-base line-numbers-mode"><pre class="language-text"><code>f(1)=1;
f(2)=2;
f(n)=f(n-1)+f(n-2);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>有了公式后，转化成代码：</p> <div class="language-C line-numbers-mode"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">f</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递归公式，然后在推敲终止条件，最后将递归公式和终止条件翻译成代码。</strong></p></div><div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>对于递归代码，这种试图想清楚整个递归过程的做法，实际上是进入了一个思维误区。很多时候，我们理解起来比较吃力，主要原因就是自己给自己制造了这种理解障碍。那正确的思维方式应该是怎样的？</p> <p>如果一个问题A可以分解为若干子问题B、C、D，你可以假设子问题B、C、D已经解决，再次基础上思考如何解决问题A。而且，你只需要思考问题A与子问题B、C、D两层之间的关系即可，不需要一层层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单很多了。</p> <p>因此，编写递归代码的关键是，<strong>只要遇到递归，我们就把它抽象成一个递归公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤</strong>。</p></div><h3 id="递归代码要警惕堆栈溢出"><a href="#递归代码要警惕堆栈溢出" class="header-anchor">#</a> 递归代码要警惕堆栈溢出</h3> <div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>堆栈溢出会造成系统性崩溃，后果会非常严重。</p> <p>系统栈或虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。</p></div><div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>避免出现堆栈溢出可以通过在代码中限制递归调用的最大深度的方式来解决这个问题。递归调用超过一定深度（比如1000）之后，就不再继续往下递归，直接返回报错。比如下面的伪代码片段，为了代码简洁，有些边界条件没有考虑，比如 x&lt;=0。</p> <div class="language-Java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 全局变量，表示递归的深度。</span>
<span class="token keyword">int</span> depth <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token operator">++</span>depth；
  <span class="token keyword">if</span> <span class="token punctuation">(</span>depth <span class="token operator">&gt;</span> <span class="token number">1000</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> exception<span class="token punctuation">;</span>
  
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div></div><h3 id="递归代码要警惕重复计算"><a href="#递归代码要警惕重复计算" class="header-anchor">#</a> 递归代码要警惕重复计算</h3> <p>刚才讲的询阶梯的递归代码例子，如果吧整个递归过程分解一下的话，是这样的：</p> <p><img src="https://cdn.jsdelivr.net/gh/AsherSun/image-host/blog-img/e7e778994e90265344f6ac9da39e01bf.webp" alt="递归分解图"></p> <p>从图中，可以直观地看到，想要计算f(5)，需要先计算f(4)和f(3)，而计算f(4)还需要计算f(3)，因此，f(3)就被计算了很多次，f(4)同理。这就是重复计算问题。</p> <p>可以通过一个数据结构来避免重复计算，比如散列表来保存已经求过的f(k)。当递归到f(k)时，先看下是否已经求解过了。</p> <p>按照这个思路来改下刚才的代码：</p> <div class="language-Java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>
  
  <span class="token comment">// hasSolvedList可以理解成一个Map，key是n，value是f(n)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>hasSolvedList<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> hasSolvedList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">f</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  hasSolvedList<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> ret<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h3 id="怎么将递归代码改写成非递归代码"><a href="#怎么将递归代码改写成非递归代码" class="header-anchor">#</a> 怎么将递归代码改写成非递归代码？</h3> <p>利是递归代码的表达力很强，写起来非常简洁；而弊就是空间复杂度高、有堆栈溢出的风险、存在重复计算、过多的函数调用会耗时较多等问题。</p> <p>把电影院的递归代码可以改成这样：</p> <div class="language-Java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ret <span class="token operator">=</span> ret <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>第二个询阶梯的递归代码可以改成这样：</p> <div class="language-Java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>
  
  <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> pre <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> prepre <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ret <span class="token operator">=</span> pre <span class="token operator">+</span> prepre<span class="token punctuation">;</span>
    prepre <span class="token operator">=</span> pre<span class="token punctuation">;</span>
    pre <span class="token operator">=</span> ret<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>笼统的讲，可以将所有的递归代码都改成这种迭代循环的非递归写法。</p> <p>只不过我们使用的栈是系统或者虚拟机本身提供的，我们没有感知罢了。如果我们自己在内存堆上实现栈，手动模拟入栈、出栈过程，这样任何递归代码都可以改写成看上去不是递归代码的样子。</p> <h2 id="_11-排序-上-为什么插入排序比冒泡排序更受欢迎"><a href="#_11-排序-上-为什么插入排序比冒泡排序更受欢迎" class="header-anchor">#</a> 11 | 排序（上）：为什么插入排序比冒泡排序更受欢迎</h2> <div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>排序算法的执行效率</p> <ol><li>最好情况、最坏情况、平均情况时间复杂度</li></ol> <p>为什么要区分这三种时间复杂度？第一，有些排序算法会区分，为了好对比，所以我们最好都做一下区分。第二，对于要排序的数据，有的接近有序，有的完全 无序。有序度不同的数据，对于排序的执行时间肯定会有影响的，我们要知道排序算法在不同数据下的西性能表现。</p> <ol start="2"><li>时间复杂度的系数、常数、低阶</li></ol> <p>时间复杂度反映的是数据规模 n 很大的时候一个增长趋势，所以它表示的时候会忽略系数、常数、低阶。在实际开发中，排序的数据规模可能是10个、100个、1000个这样规模较小的数据，所以，在对同一阶时间复杂度的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进来。</p> <ol start="3"><li>比较次数和交换（或移动）次数</li></ol> <p>基于比较的排序算法的执行过程，会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。如果我们在分析排序算法的执行效率的时候，应该把比较次数和交换（或移动）次数也考虑进去。</p></div><div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>排序算法的内存消耗</p> <p>针对排序算法的空间复杂度，引入了一个新的概念，<strong>原地排序（Sorted in place）</strong>。就是特指空间复杂度是O(1)的排序算法。</p></div><div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>排序算法的稳定性</p> <p>针对排序算法，还有一个重要的度量指标，<strong>稳定性</strong>。这个概念是说：如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。</p> <p>举一个例子，有一组数据2、9、3、4、8、3。按照大小排序之后就是2、3、3、4、8、9。经过某种排序算法之后，如果两个3的前后顺序没有改变，那么就把这种排序算法叫做<strong>稳定的排序算法</strong>。如果前后顺序发生变化，就叫做<strong>不稳定的排序算法</strong>。</p></div><h3 id="冒泡排序-bubble-sort"><a href="#冒泡排序-bubble-sort" class="header-anchor">#</a> 冒泡排序（Bubble Sort）</h3> <div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复n次，就完成了n个数据的排序工作。</p></div><div class="note-block"><svg t="1665301607231" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4678" width="200" height="200" class="icon" style="width:20px;height:20px;"><path d="M512 469.333333m-426.666667 0a426.666667 426.666667 0 1 0 853.333334 0 426.666667 426.666667 0 1 0-853.333334 0Z" fill="#FFF59D" p-id="4679"></path><path d="M789.333333 469.333333c0-164.266667-140.8-294.4-309.333333-275.2-128 14.933333-230.4 117.333333-243.2 245.333334-10.666667 98.133333 29.866667 185.6 98.133333 241.066666 29.866667 25.6 49.066667 61.866667 49.066667 102.4v6.4h256v-2.133333c0-38.4 17.066667-76.8 46.933333-102.4 61.866667-51.2 102.4-128 102.4-215.466667z" fill="#FBC02D" p-id="4680"></path><path d="M652.8 430.933333l-64-42.666666c-6.4-4.266667-17.066667-4.266667-23.466667 0L512 422.4l-51.2-34.133333c-6.4-4.266667-17.066667-4.266667-23.466667 0l-64 42.666666c-4.266667 4.266667-8.533333 8.533333-8.533333 14.933334s0 12.8 4.266667 17.066666l81.066666 100.266667V789.333333h42.666667V554.666667c0-4.266667-2.133333-8.533333-4.266667-12.8l-70.4-87.466667 32-21.333333 51.2 34.133333c6.4 4.266667 17.066667 4.266667 23.466667 0l51.2-34.133333 32 21.333333-70.4 87.466667c-2.133333 4.266667-4.266667 8.533333-4.266667 12.8v234.666666h42.666667V563.2l81.066667-100.266667c4.266667-4.266667 6.4-10.666667 4.266666-17.066666s-4.266667-12.8-8.533333-14.933334z" fill="#FFF59D" p-id="4681"></path><path d="M512 938.666667m-64 0a64 64 0 1 0 128 0 64 64 0 1 0-128 0Z" fill="#5C6BC0" p-id="4682"></path><path d="M554.666667 960h-85.333334c-46.933333 0-85.333333-38.4-85.333333-85.333333v-106.666667h256v106.666667c0 46.933333-38.4 85.333333-85.333333 85.333333z" fill="#9FA8DA" p-id="4683"></path><path d="M640 874.666667l-247.466667 34.133333c6.4 14.933333 19.2 29.866667 34.133334 38.4l200.533333-27.733333c8.533333-12.8 12.8-27.733333 12.8-44.8zM384 825.6v42.666667L640 832v-42.666667z" fill="#5C6BC0" p-id="4684"></path></svg> <style>
          blockquote {
            background-color: var(--code-color);
            border-color: #67cc86;
            border-left-width: 0.5rem;
            border-left-style: solid;
          }
        </style><p>比如，我们对这一组数据4、5、6、3、2、1，从小到大进行排序。第一次冒泡是这样的：</p> <p><img src="https://cdn.jsdelivr.net/gh/AsherSun/image-host/blog-img/4038f64f47975ab9f519e4f739e464e9.webp" alt="第一次冒泡排序"></p> <p>可以看出，经过一次冒泡排序之后，6这个元素已经存储在正确的位置上。要想完成所有数据的排序，只需要进行6次这样的冒泡操作就行了。</p> <p><img src="https://cdn.jsdelivr.net/gh/AsherSun/image-host/blog-img/9246f12cca22e5d872cbfce302ef4d09.webp" alt="最终冒泡排序"></p> <p>刚才的冒泡排序还可以优化。当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作。如下图元素排序，只需要4次冒泡操作就可以了。</p> <p><img src="https://cdn.jsdelivr.net/gh/AsherSun/image-host/blog-img/a9783a3b13c11a5e064c5306c261e8e6.webp" alt="优化后的冒泡排序"></p></div><div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>冒泡排序算法的代码：</p> <div class="language-Java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 冒泡排序，a表示数组，n表示数组大小</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
 
 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 提前退出冒泡循环的标志位</span>
    <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> a<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 交换</span>
        <span class="token keyword">int</span> tmp <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
        a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        a<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
        flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token comment">// 表示有数据交换      </span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token comment">// 没有数据交换，提前退出</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><ul><li>冒泡的过程中只涉及相邻数据的交换，只需要常量级的数据空间，所以它的空间复杂度为O(1)，是一个<strong>原地排序算法</strong>。</li> <li>冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，所以冒泡排序是<strong>稳定的排序算法</strong>。</li></ul></div><h3 id="插入排序-insertion-sort"><a href="#插入排序-insertion-sort" class="header-anchor">#</a> 插入排序（Insertion Sort）</h3> <div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>一个有序的数组，往里面添加一个新的数据后，如何继续保持数据有序？我们只需要遍历数组，找到数据应该插入的位置将其插入即可。</p> <p><img src="https://cdn.jsdelivr.net/gh/AsherSun/image-host/blog-img/7b257e179787c633d2bd171a764171a6.webp" alt="有序插入"></p> <p>这是一个动态排序的过程，即动态地往有序集合中添加数据，可以通过这种方法保持集合中的数据一直有序。而对于一组静态数据，也可以借鉴上面的插入方法，来进行排序，于是就有了插入排序算法。</p></div><div class="note-block"><svg t="1665301607231" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4678" width="200" height="200" class="icon" style="width:20px;height:20px;"><path d="M512 469.333333m-426.666667 0a426.666667 426.666667 0 1 0 853.333334 0 426.666667 426.666667 0 1 0-853.333334 0Z" fill="#FFF59D" p-id="4679"></path><path d="M789.333333 469.333333c0-164.266667-140.8-294.4-309.333333-275.2-128 14.933333-230.4 117.333333-243.2 245.333334-10.666667 98.133333 29.866667 185.6 98.133333 241.066666 29.866667 25.6 49.066667 61.866667 49.066667 102.4v6.4h256v-2.133333c0-38.4 17.066667-76.8 46.933333-102.4 61.866667-51.2 102.4-128 102.4-215.466667z" fill="#FBC02D" p-id="4680"></path><path d="M652.8 430.933333l-64-42.666666c-6.4-4.266667-17.066667-4.266667-23.466667 0L512 422.4l-51.2-34.133333c-6.4-4.266667-17.066667-4.266667-23.466667 0l-64 42.666666c-4.266667 4.266667-8.533333 8.533333-8.533333 14.933334s0 12.8 4.266667 17.066666l81.066666 100.266667V789.333333h42.666667V554.666667c0-4.266667-2.133333-8.533333-4.266667-12.8l-70.4-87.466667 32-21.333333 51.2 34.133333c6.4 4.266667 17.066667 4.266667 23.466667 0l51.2-34.133333 32 21.333333-70.4 87.466667c-2.133333 4.266667-4.266667 8.533333-4.266667 12.8v234.666666h42.666667V563.2l81.066667-100.266667c4.266667-4.266667 6.4-10.666667 4.266666-17.066666s-4.266667-12.8-8.533333-14.933334z" fill="#FFF59D" p-id="4681"></path><path d="M512 938.666667m-64 0a64 64 0 1 0 128 0 64 64 0 1 0-128 0Z" fill="#5C6BC0" p-id="4682"></path><path d="M554.666667 960h-85.333334c-46.933333 0-85.333333-38.4-85.333333-85.333333v-106.666667h256v106.666667c0 46.933333-38.4 85.333333-85.333333 85.333333z" fill="#9FA8DA" p-id="4683"></path><path d="M640 874.666667l-247.466667 34.133333c6.4 14.933333 19.2 29.866667 34.133334 38.4l200.533333-27.733333c8.533333-12.8 12.8-27.733333 12.8-44.8zM384 825.6v42.666667L640 832v-42.666667z" fill="#5C6BC0" p-id="4684"></path></svg> <style>
          blockquote {
            background-color: var(--code-color);
            border-color: #67cc86;
            border-left-width: 0.5rem;
            border-left-style: solid;
          }
        </style><p>插入排序的思想</p> <p>将数组中的数据分为两个区间，<strong>已排序区间</strong>和<strong>未排序区间</strong>。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。</p> <p>如图所示，要排序的数据是4、5、6、1、3、2。
<img src="https://cdn.jsdelivr.net/gh/AsherSun/image-host/blog-img/b60f61ec487358ac037bf2b6974d2de1.webp" alt="插入排序"></p></div><div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>插入排序的算法</p> <div class="language-Java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 插入排序，a表示数组，n表示数组大小</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insertionSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>

  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> value <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">// 查找插入的位置</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> j <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        a<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 数据移动</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    a<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span> <span class="token comment">// 插入数据</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><ul><li>插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是O(1)，这是一个<strong>原地排序算法</strong>。</li> <li>在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是<strong>稳定的排序算法</strong>。</li></ul></div><h3 id="选择排序"><a href="#选择排序" class="header-anchor">#</a> 选择排序</h3> <div class="note-block"><svg t="1665301607231" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4678" width="200" height="200" class="icon" style="width:20px;height:20px;"><path d="M512 469.333333m-426.666667 0a426.666667 426.666667 0 1 0 853.333334 0 426.666667 426.666667 0 1 0-853.333334 0Z" fill="#FFF59D" p-id="4679"></path><path d="M789.333333 469.333333c0-164.266667-140.8-294.4-309.333333-275.2-128 14.933333-230.4 117.333333-243.2 245.333334-10.666667 98.133333 29.866667 185.6 98.133333 241.066666 29.866667 25.6 49.066667 61.866667 49.066667 102.4v6.4h256v-2.133333c0-38.4 17.066667-76.8 46.933333-102.4 61.866667-51.2 102.4-128 102.4-215.466667z" fill="#FBC02D" p-id="4680"></path><path d="M652.8 430.933333l-64-42.666666c-6.4-4.266667-17.066667-4.266667-23.466667 0L512 422.4l-51.2-34.133333c-6.4-4.266667-17.066667-4.266667-23.466667 0l-64 42.666666c-4.266667 4.266667-8.533333 8.533333-8.533333 14.933334s0 12.8 4.266667 17.066666l81.066666 100.266667V789.333333h42.666667V554.666667c0-4.266667-2.133333-8.533333-4.266667-12.8l-70.4-87.466667 32-21.333333 51.2 34.133333c6.4 4.266667 17.066667 4.266667 23.466667 0l51.2-34.133333 32 21.333333-70.4 87.466667c-2.133333 4.266667-4.266667 8.533333-4.266667 12.8v234.666666h42.666667V563.2l81.066667-100.266667c4.266667-4.266667 6.4-10.666667 4.266666-17.066666s-4.266667-12.8-8.533333-14.933334z" fill="#FFF59D" p-id="4681"></path><path d="M512 938.666667m-64 0a64 64 0 1 0 128 0 64 64 0 1 0-128 0Z" fill="#5C6BC0" p-id="4682"></path><path d="M554.666667 960h-85.333334c-46.933333 0-85.333333-38.4-85.333333-85.333333v-106.666667h256v106.666667c0 46.933333-38.4 85.333333-85.333333 85.333333z" fill="#9FA8DA" p-id="4683"></path><path d="M640 874.666667l-247.466667 34.133333c6.4 14.933333 19.2 29.866667 34.133334 38.4l200.533333-27.733333c8.533333-12.8 12.8-27.733333 12.8-44.8zM384 825.6v42.666667L640 832v-42.666667z" fill="#5C6BC0" p-id="4684"></path></svg> <style>
          blockquote {
            background-color: var(--code-color);
            border-color: #67cc86;
            border-left-width: 0.5rem;
            border-left-style: solid;
          }
        </style><p>选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小 的元素，将其放到已排序区间的末尾。</p> <p><img src="https://cdn.jsdelivr.net/gh/AsherSun/image-host/blog-img/32371475a0b08f0db9861d102474181d.webp" alt="选择排序"></p> <ul><li>选择排序的空间复杂度为O(1)，最好情况、最坏情况和平均情况时间复杂度都为O(n²)</li> <li>选择排序是一种不稳定的排序算法。从图中可以看出，选择排序每次都要找剩余排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性。</li></ul></div><h3 id="为什么插入排序比冒泡排序更受欢迎"><a href="#为什么插入排序比冒泡排序更受欢迎" class="header-anchor">#</a> 为什么插入排序比冒泡排序更受欢迎？</h3> <p>从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要3个赋值操作，而插入排序只需要1个。</p> <div class="language-Java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 冒泡排序中数据的交换操作：</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> a<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 交换</span>
   <span class="token keyword">int</span> tmp <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
   a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
   a<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
   flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 插入排序中数据的移动操作：</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  a<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 数据移动</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>所以，虽然冒泡排序和插入排序在时间复杂度上是一样的，都是O(n²)，但是如果我们希望把性能优化做到极致，那肯定首选插入排序。</p> <h2 id="_12-排序-下-如何用快排思想在o-n-内查找第k大元素"><a href="#_12-排序-下-如何用快排思想在o-n-内查找第k大元素" class="header-anchor">#</a> 12 | 排序（下）：如何用快排思想在O(n)内查找第K大元素？</h2> <h3 id="归并排序-merge-sort-的原理"><a href="#归并排序-merge-sort-的原理" class="header-anchor">#</a> 归并排序（Merge Sort）的原理</h3> <p>归并排序的思想：先把数组从中间分成前后两部分，然后对前后两部分分别排序，在将排好序的两部分合并在一起，这样整个数组就都有序了。</p> <p><img src="https://cdn.jsdelivr.net/gh/AsherSun/image-host/blog-img/db7f892d3355ef74da9cd64aa926dc2b.webp" alt="归并排序分解图"></p> <p>归并排序使用的是<strong>分治思想</strong>。分治，就是分而治之，将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了。分治算法一般是用递归来实现的。<strong>分治是一种解决问题的处理思想，递归是一种编程技巧</strong></p> <p>归并排序的递推公式：</p> <div class="language-base line-numbers-mode"><pre class="language-text"><code>递推公式：
merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))

终止条件：
p &gt;= r 不用再继续分解
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>p...r表示数组的开始下标和结束下标。merge_sort(p...q)和merge(q+1...r)，其中下标q等于p和r的中间位置。也就是(p+r)/2。</p> <p>伪代码表示归并算法：</p> <div class="language-Java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 归并排序算法, A是数组，n表示数组大小</span>
<span class="token function">merge_sort</span><span class="token punctuation">(</span><span class="token class-name">A</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">merge_sort_c</span><span class="token punctuation">(</span><span class="token class-name">A</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 递归调用函数</span>
<span class="token function">merge_sort_c</span><span class="token punctuation">(</span><span class="token class-name">A</span><span class="token punctuation">,</span> p<span class="token punctuation">,</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 递归终止条件</span>
  <span class="token keyword">if</span> p <span class="token operator">&gt;=</span> r  then <span class="token keyword">return</span>

  <span class="token comment">// 取p到r之间的中间位置q</span>
  q <span class="token operator">=</span> <span class="token punctuation">(</span>p<span class="token operator">+</span>r<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span>
  <span class="token comment">// 分治递归</span>
  <span class="token function">merge_sort_c</span><span class="token punctuation">(</span><span class="token class-name">A</span><span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span>
  <span class="token function">merge_sort_c</span><span class="token punctuation">(</span><span class="token class-name">A</span><span class="token punctuation">,</span> q<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span>
  <span class="token comment">// 将A[p...q]和A[q+1...r]合并为A[p...r]</span>
  <span class="token function">merge</span><span class="token punctuation">(</span><span class="token class-name">A</span><span class="token punctuation">[</span>p<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>r<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token class-name">A</span><span class="token punctuation">[</span>p<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>q<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token class-name">A</span><span class="token punctuation">[</span>q<span class="token operator">+</span><span class="token number">1.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>merge(A[p...r], A[p...q], A[q+1...r])这个函数的作用就是将已经有序的A[p...q]和A[q+1...r]合并成一个有序的数组，并且放入A[p...r]。</p> <p>如图所示，申请一个临时数组tmp，大小与A[p...r]相同。用两个游标i和j，分别指向A[p...q]和A[q+1...r]的第一个元素。比较这两个元素A[i]和A[j]，如果A[i]&lt;=A[j]，就把A[i]放入到临时数组tmp，并且i后移一位，否则将A[j]放入到tmp，j后移一位。重复上述逻辑直到结束，最后再把临时数组tmp中的数据拷贝到原数组A[p...r]中。</p> <p><img src="https://cdn.jsdelivr.net/gh/AsherSun/image-host/blog-img/95897ade4f7ad5d10af057b1d144a22f.webp" alt="归并排序合并逻辑"></p> <p>merge函数的伪代码如下：</p> <div class="language-Java line-numbers-mode"><pre class="language-java"><code><span class="token function">merge</span><span class="token punctuation">(</span><span class="token class-name">A</span><span class="token punctuation">[</span>p<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>r<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token class-name">A</span><span class="token punctuation">[</span>p<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>q<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token class-name">A</span><span class="token punctuation">[</span>q<span class="token operator">+</span><span class="token number">1.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> i <span class="token operator">:</span><span class="token operator">=</span> p，j <span class="token operator">:</span><span class="token operator">=</span> q<span class="token operator">+</span><span class="token number">1</span>，k <span class="token operator">:</span><span class="token operator">=</span> <span class="token number">0</span> <span class="token comment">// 初始化变量i, j, k</span>
  <span class="token keyword">var</span> tmp <span class="token operator">:</span><span class="token operator">=</span> <span class="token keyword">new</span> array<span class="token punctuation">[</span><span class="token number">0.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>r<span class="token operator">-</span>p<span class="token punctuation">]</span> <span class="token comment">// 申请一个大小跟A[p...r]一样的临时数组</span>
  <span class="token keyword">while</span> i<span class="token operator">&lt;=</span>q AND j<span class="token operator">&lt;=</span>r <span class="token keyword">do</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token class-name">A</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token class-name">A</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token punctuation">{</span>
      tmp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">A</span><span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token comment">// i++等于i:=i+1</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      tmp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">A</span><span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  
  <span class="token comment">// 判断哪个子数组中有剩余的数据</span>
  <span class="token keyword">var</span> start <span class="token operator">:</span><span class="token operator">=</span> i，end <span class="token operator">:</span><span class="token operator">=</span> q
  <span class="token keyword">if</span> j<span class="token operator">&lt;=</span>r then start <span class="token operator">:</span><span class="token operator">=</span> j<span class="token punctuation">,</span> end<span class="token operator">:</span><span class="token operator">=</span>r
  
  <span class="token comment">// 将剩余的数据拷贝到临时数组tmp</span>
  <span class="token keyword">while</span> start <span class="token operator">&lt;=</span> end <span class="token keyword">do</span> <span class="token punctuation">{</span>
    tmp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">A</span><span class="token punctuation">[</span>start<span class="token operator">++</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
  
  <span class="token comment">// 将tmp中的数组拷贝回A[p...r]</span>
  <span class="token keyword">for</span> i<span class="token operator">:</span><span class="token operator">=</span><span class="token number">0</span> <span class="token keyword">to</span> r<span class="token operator">-</span>p <span class="token keyword">do</span> <span class="token punctuation">{</span>
    <span class="token class-name">A</span><span class="token punctuation">[</span>p<span class="token operator">+</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><h3 id="归并排序的性能分析"><a href="#归并排序的性能分析" class="header-anchor">#</a> 归并排序的性能分析</h3> <p>归并排序稳不稳定关键要看merge函数，在合并的过程中，如果A[p...q]和A[q+1...r]之间有相同的元素，那我们可以像伪代码中那样，先把A[p...q]中的元素放入tmp数组。这样就保证了值相同的元素，在合并前后的先后顺序不变。所以，归并排序是一个稳定的排序算法。</p> <p>归并排序的时间复杂度是O(nlogn)。</p> <p>归并排序不是原地排序算法，归并排序的空间复杂度是O(n)。</p> <h3 id="快速排序-quicksort-的原理"><a href="#快速排序-quicksort-的原理" class="header-anchor">#</a> 快速排序（Quicksort）的原理</h3> <p>快排利用的也是分治思想。快排的思想：如果要排序数组中下标从p 到r 之间的一组数据，我们选择p到r之间的任意一个数据作为pivot（分区点）。</p> <p>遍历p到r之间的数据，将小于pivot的放到左边，将大于pivot的放到右边，将pivot放到中间。经过这一步骤之后，数组p到r之间的数据就被分成了三个部分，前面p到q-1之间都是小于pivot的，中间是pivot，后面的q+1到r之间是大于pivot的。</p> <p><img src="https://cdn.jsdelivr.net/gh/AsherSun/image-host/blog-img/4d892c3a2e08a17f16097d07ea088a81.webp" alt="快速排序分解图"></p> <p>用递归排序下标从p到q-1之间的数据和下标从q+1到r之间的数据，知道区间缩小为1，就说明所有的数据都有序了。</p> <p>递推公式如下：</p> <div class="language-base line-numbers-mode"><pre class="language-text"><code>递推公式：
quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1… r)

终止条件：
p &gt;= r
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>递归的伪代码：</p> <div class="language-Java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 快速排序，A是数组，n表示数组的大小</span>
<span class="token function">quick_sort</span><span class="token punctuation">(</span><span class="token class-name">A</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">quick_sort_c</span><span class="token punctuation">(</span><span class="token class-name">A</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// 快速排序递归函数，p,r为下标</span>
<span class="token function">quick_sort_c</span><span class="token punctuation">(</span><span class="token class-name">A</span><span class="token punctuation">,</span> p<span class="token punctuation">,</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> p <span class="token operator">&gt;=</span> r then <span class="token keyword">return</span>
  
  q <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token class-name">A</span><span class="token punctuation">,</span> p<span class="token punctuation">,</span> r<span class="token punctuation">)</span> <span class="token comment">// 获取分区点</span>
  <span class="token function">quick_sort_c</span><span class="token punctuation">(</span><span class="token class-name">A</span><span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token function">quick_sort_c</span><span class="token punctuation">(</span><span class="token class-name">A</span><span class="token punctuation">,</span> q<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>partition()分区函数实际上会随机选择一个元素作为pivot(一般情况下，可以选择p到r区间的最后一个元素)，然后对A[p...r]分区，函数返回pivot的下标。</p> <p>在不考虑空间消耗的情况下，partition分区函数可以写得非常简单。申请两个临时数组X和Y，遍历A[p...r]，将小于pivot的元素都拷贝到临时数组X，将大于pivot的元素都拷贝到临时数组Y。最后再将数组X和数组Y中数据顺序拷贝到A[p...r]。</p> <p><img src="https://cdn.jsdelivr.net/gh/AsherSun/image-host/blog-img/6643bc3cef766f5b3e4526c332c60adc.webp" alt="分区示意"></p> <p>上述这种快排方式就不是原地算法了。如果希望快排是原地算法，那它的空间复杂度就得是O(1)。所以，需要在A[p...r]的原地完成分区操作。</p> <p>伪代码如下：</p> <div class="language-Java line-numbers-mode"><pre class="language-java"><code><span class="token function">partition</span><span class="token punctuation">(</span><span class="token class-name">A</span><span class="token punctuation">,</span> p<span class="token punctuation">,</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  pivot <span class="token operator">:</span><span class="token operator">=</span> <span class="token class-name">A</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span>
  i <span class="token operator">:</span><span class="token operator">=</span> p
  <span class="token keyword">for</span> j <span class="token operator">:</span><span class="token operator">=</span> p <span class="token keyword">to</span> r<span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">do</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token class-name">A</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot <span class="token punctuation">{</span>
      swap <span class="token class-name">A</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">with</span> <span class="token class-name">A</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>
      i <span class="token operator">:</span><span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  swap <span class="token class-name">A</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">with</span> <span class="token class-name">A</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span>
  <span class="token keyword">return</span> i
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>代码的逻辑示意图：</p> <p><img src="https://cdn.jsdelivr.net/gh/AsherSun/image-host/blog-img/086002d67995e4769473b3f50dd96de7.webp" alt="原地分区示意图"></p> <p><strong>归并排序和快排的区别在哪里？</strong></p> <p><img src="https://cdn.jsdelivr.net/gh/AsherSun/image-host/blog-img/aa03ae570dace416127c9ccf9db8ac05.webp" alt="归并和快排"></p> <p>可以发现，归并排序的处理过程是<strong>由下到上的</strong>，先处理子问题，然后再合并。而快排正好相反，它的处理过程是<strong>由上到下</strong>的，先分区，然后再处理子问题。归并排序虽然是稳定的、时间复杂度为 O(nlogn) 的排序算法，但是它是非原地排序算法。我们前面讲过，归并之所以是非原地排序算法，主要原因是合并函数无法在原地执行。快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。</p> <h3 id="快速排序的性能分析"><a href="#快速排序的性能分析" class="header-anchor">#</a> 快速排序的性能分析</h3> <ul><li>快排是一种原地、不稳定的排序算法。</li> <li>快速排序的时间复杂度是O(nlogn)。</li></ul> <h2 id="_13-线性排序-如何根据年龄给100万用户数据排序"><a href="#_13-线性排序-如何根据年龄给100万用户数据排序" class="header-anchor">#</a> 13 | 线性排序：如何根据年龄给100万用户数据排序？</h2> <div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>三种事件复杂度是O(n)的排序算法：桶排序、计数排序、基数排序。因为这些排序算法的时间复杂度是线性的，所以我们把这类排序算法叫做<strong>线性排序（Linear sort）</strong>。这三个算法是非基于比较的排序算法，都不涉及元素之间的比较操作。</p></div><h3 id="桶排序-bucket-sort"><a href="#桶排序-bucket-sort" class="header-anchor">#</a> 桶排序（Bucket Sort）</h3> <div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>通排序，核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个 桶里的数据按照顺序依次取出，组成的序列 就是有序的了。</p> <p><img src="https://cdn.jsdelivr.net/gh/AsherSun/image-host/blog-img/987564607b864255f81686829503abae.webp" alt="桶排序"></p></div><div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>桶排序的时间复杂度为什么是O(n)？</p> <p>如果要排序的数据有n个，我们把它们均匀地划分到m个桶内，每个桶内就有k=n/m个元素。每个桶内部使用快速排序，时间复杂度为O(k * logk)。m个桶排序的时间复杂度就是O(m * k * logk)，因为k=n/m，所以整个桶排序的时间复杂度就是O(n * log(n/m))。当桶的个数m接近数据个数n时，log(n/m)就是一个非常小的常量，这个时候桶排序的时间复杂度接近O(n)。</p></div><div class="note-block"><svg t="1665486468429" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16415" width="200" height="200" class="icon" style="width:20px;height:20px;fill:var(--text-color);"><path d="M944.981319 147.815557l0 413.93759c0 7.367805-3.949962 14.152325-10.345626 17.795295-3.755534 2.13871-93.335758 52.352345-208.80563 52.352345-111.100354 0-181.892677-20.537755-244.355287-38.660508-51.001581-14.797008-95.054913-27.578102-153.035442-27.578102-20.701484 0-40.97318 0.818645-60.262502 2.425236-11.266601 0.941442-21.151739-7.429203-22.093181-18.695804-0.931209-11.266601 7.429203-21.151739 18.695804-22.093181 20.414959-1.698688 41.832757-2.568499 63.659879-2.568499 63.803141 0 112.686479 14.183024 164.445306 29.194926 62.759369 18.21485 127.657448 37.043684 232.945423 37.043684 83.276658 0 152.800082-29.40982 178.219008-41.699728l0-368.963283c-37.83163 16.260335-102.095259 37.647435-178.219008 37.647435-86.663802 0-147.908678-26.125007-207.127408-51.380204-57.827033-24.661679-112.440885-47.962362-190.263321-47.962362-77.218686 0-123.420961 7.592932-148.573827 13.96813-14.612813 3.704368-24.02723 7.429203-29.645181 10.120498l0 750.216473c0 11.2973-9.168824 20.466124-20.466124 20.466124-11.307533 0-20.466124-9.168824-20.466124-20.466124l0-761.657037c0-5.577019 2.27174-10.908444 6.293333-14.766308 6.764054-6.487761 48.770773-38.814004 212.857922-38.814004 86.193081 0 147.263995 26.053376 206.318996 51.247174 57.990762 24.733311 112.768343 48.095391 191.071733 48.095391 94.348831 0 168.477133-36.132942 188.95349-47.205115 6.334265-3.428076 14.019295-3.27458 20.210297 0.419556C941.195086 133.929292 944.981319 140.601248 944.981319 147.815557z" p-id="16416"></path></svg> <style>
        blockquote {
          background-color: var(--code-color);
          border-color: #67cc86;
          border-left-width: 0.5rem;
          border-left-style: solid;
        }
      </style><p>使用桶排序需要满足这些条件：</p> <ul><li></li></ul></div></div></div> <footer class="page-edit" style="display:none;"><!----> <!----></footer> <!----> <!----> <!----></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/assets/js/app.730fe383.js" defer></script><script src="/assets/js/3.9989142c.js" defer></script><script src="/assets/js/1.3a008db8.js" defer></script><script src="/assets/js/44.623633a1.js" defer></script>
  </body>
</html>
