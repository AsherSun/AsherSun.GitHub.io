(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{549:function(t,s,a){"use strict";a.r(s);var e=a(4),v=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"问题列表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#问题列表"}},[t._v("#")]),t._v(" 问题列表")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("相同一份数据(数据的内存指针是同一份)。在一个函数中使用(该函数的父/祖宗函数内部已经缓存了该数据)。请问：直接使用函数内部数据的方式JS执行效率高 还是直接找到该数据的引用使用的方式JS执行效率高呢？")])]),t._v(" "),a("li",[a("p",[a("code",[t._v("vue template")]),t._v(" 为什么可以使用"),a("code",[t._v("v-if")]),t._v("指令而不能使用"),a("code",[t._v("v-show")]),t._v("指令？")]),t._v(" "),a("div",{staticClass:"language-html line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-html"}},[a("code",[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("template")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("div")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n\t\t"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("template")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("v-if")]),a("span",{pre:!0,attrs:{class:"token attr-value"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("xxx"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n\t\t\t// TODO ....\n\t\t"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("template")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("div")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("template")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br")])])])]),t._v(" "),a("h2",{attrs:{id:"解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解"}},[t._v("#")]),t._v(" 解")]),t._v(" "),a("h3",{attrs:{id:"问题1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#问题1"}},[t._v("#")]),t._v(" 问题1：")]),t._v(" "),a("h3",{attrs:{id:"问题2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#问题2"}},[t._v("#")]),t._v(" 问题2:")]),t._v(" "),a("p",[t._v("首先我们要清楚"),a("code",[t._v("vue template")]),t._v("方式开发，在开发过程中是 html结构。但是浏览器根本不识别这种"),a("code",[t._v("template")]),t._v("的结构。因为浏览器没有解析 vue 指令的能力。所以vue 最终会把template 编译成 "),a("code",[t._v("reander")]),t._v("函数。将 vue 指令解析为js语法。这样就能理解 为什么可以在 "),a("code",[t._v("template")]),t._v(" 上使用 "),a("code",[t._v("v-if")]),t._v(" 指令而不能使用 "),a("code",[t._v("v-show")]),t._v(" 指令。")]),t._v(" "),a("p",[a("strong",[t._v("先理解下"),a("code",[t._v("v-if")]),t._v("与"),a("code",[t._v("v-show")]),t._v("的区别")])]),t._v(" "),a("ul",[a("li",[a("code",[t._v("v-show")]),t._v(" 会让DOM元素"),a("code",[t._v("display:none")])]),t._v(" "),a("li",[a("code",[t._v("v-if")]),t._v(" 会让DOM 元素销毁 (浏览器的html 结构中看不到)")])]),t._v(" "),a("p",[t._v("上面是vue的两种指令最容易发现的区别，细心的同学都能发现的😂")]),t._v(" "),a("p",[a("strong",[t._v("理解"),a("code",[t._v("v-if")]),t._v("与"),a("code",[t._v("v-show")]),t._v("在 "),a("code",[t._v("render")]),t._v("函数中的作用")])]),t._v(" "),a("ul",[a("li",[t._v("把 "),a("code",[t._v("template")]),t._v("解析为"),a("code",[t._v("render")]),t._v("函数。当vue的模版解析器发现了"),a("code",[t._v("v-if")]),t._v("语法糖，那么会把"),a("code",[t._v("v-if")]),t._v("解析为 js 中的 "),a("code",[t._v("if() {} ")]),t._v("语句")]),t._v(" "),a("li",[a("code",[t._v("v-show")]),t._v("并不会解析为"),t._v("if"),t._v("语句，而是通过"),t._v("v-show"),t._v("的条件，给"),a("code",[t._v("DOM")]),t._v("元素添加 "),a("code",[t._v("display ")]),t._v("属性")])]),t._v(" "),a("p",[t._v("上面的区别解释了vue 官方文档上的一句话"),a("code",[t._v("v-if")]),t._v("在初次渲染的时候效率会更高一些，而"),a("code",[t._v("v-show")]),t._v("更适合DOM的重复渲染")]),t._v(" "),a("p",[a("strong",[t._v("本质区别")])]),t._v(" "),a("p",[a("code",[t._v("v-if")]),t._v("中的条件可以让"),a("code",[t._v("render")]),t._v("函数中的虚拟"),a("code",[t._v("DOM")]),t._v("不生成，从而也就没有真实的"),a("code",[t._v("DOM")]),t._v("节点。\n"),a("code",[t._v("v-show")]),t._v("中的条件，无论“真假” 都会生成虚拟"),a("code",[t._v("DOM")]),t._v("，并且渲染成真实"),a("code",[t._v("DOM")])])])}),[],!1,null,null,null);s.default=v.exports}}]);